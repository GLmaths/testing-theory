\section{Conclusion}
\label{sec:conclusion}


Hopefully there is something smart to say.


%% %%%% OLD TEXT FROM ESOP PAPER
%% In this paper we have shown that the standard characterisations of
%%   the \mustpreorder by De Nicola and
%%   Hennessy~\cite{DBLP:journals/tcs/NicolaH84,DBLP:books/daglib/0066919}
%%   are sound and complete also in an asynchronous setting, provided servers are
%%   enhanced with the forwarding ability.
%%   \rlem{liftFW-works} shows that this lifting is always possible.
%%   %
%%   We have also shown that the standard coinductive characterisation carries over to the
%%   asynchronous setting.
%%   %
%%   Our results 
%%   are supported by 
%%   the first mechanisation of the \mustpreorder, and increase proof
%%   (i.e. code) factorisation and reusability since the alternative preorders
%%   do not need to be changed when shifting between synchronous and
%%   asynchronous semantics: it is enough to parameterise the proofs on
%%   the set of non-blocking actions.
%% %
%%   \rcor{testleqS-equals-failleq} states that \mustpreorder and failure
%%   refinement essentially coincide. This might spur further interest in
%%   the mechanisations of the latter
%%   \cite{HOL-CSP-AFP,DBLP:journals/acta/BaxterRC22}, possibly leading
%%   to a joint development.%



%% \paragraph{Proof method for \mustpreorder}
%% Theorems \ref{thm:testleqS-equals-asleq}, \ref{thm:coinductive-char-equiv-main}
%% and \ref{thm:testleqS-equals-mustsetleq} endow researchers in programming
%% languages for message-passing software with a proof method for~$\testleqS$,
%% namely: to define for their calculi an LTS that enjoys the axioms of
%% output-buffered agents with feedback.
%% An example of this approach is \rcor{characterisation-for-aCCS}.


%% \paragraph{Live programs have barred trees}  We argued that a proof
%% of $\Must{\server}{\client}$ is a proof of liveness (of the
%% client). This paper is thus de facto an example that proving
%% liveness amounts to prove that a computational tree has a bar (identified
%% by the predicate $\goodSym$), and hence \barinduction is a natural way
%% to reason constructively on liveness-preserving manipulations on programs.
%% While this fact seems to be by and large 
%% unexploited by the PL community, we believe that it may 
%% be of interest to practitioners reasoning on liveness
%% properties 
%% in theorem provers in particular, and to the PL
%% community at large.

%% \paragraph{Mechanisation} %
%% Boreale and Gadducci~\cite{DBLP:journals/tcs/BorealeG06} remark that the
%% \mustpreorder lacks a tractable proof method.  In constrast, we argue that our
%% contributions, in particular the coinductive characterisation
%% (\rthm{coinductive-char-equiv-main}), being fully mechanised in Coq, let
%% practitioners pursue non-trivial results about testing preorders for real-world
%% programming languages.  
%% %
%% To make this point, we have proved a form of code-hoisting using this
%% characterisation.
%% %
%% Our mechanisation lowers the barrier to entry for
%% researchers versed into theorem provers and wishing to use testing preorders;
%% adds to the toolkit of Coq users an alternative to the well-known (and already
%% mechanised) bisimulation equivalence \cite{DBLP:conf/lics/Pous16}; and provides
%% a starting point for researchers willing to study testing preorders and
%% analogous refinements within type theory.  Our code is open-source and available
%% on-line. %Practitioners
%% Researchers working on testing preorders may benefit from it, as
%% there are analogies between reasoning techniques for \textsc{May}, $\opMust$,
%% \textsc{Compliance}, \textsc{Should}, and \textsc{Fair} testing. For instance
%% Baldan et al. show with pen and paper that a technique similar to forwarding
%% works to characterise the $\May$-preorder~\cite{DBLP:conf/birthday/BaldanBGV15}.
%% %  

%% \paragraph{Future work}  Thanks to Theorems \ref{thm:testleqS-equals-asleq},
%% \ref{thm:coinductive-char-equiv-main} and \ref{thm:testleqS-equals-mustsetleq}
%% we can now set out to (1) devise an
%% axiomatisation of~$\testleqS$ for asynchronous calculi, as done in
%% \cite{DBLP:journals/fac/HennessyI93,DBLP:journals/iandc/BorealeN95,DBLP:books/daglib/0066919,DBLP:journals/tcs/Hennessy02}
%% for synchronous ones; (2) study for which asynchronous calculi~$\testleqS$ is a
%% pre-congruence; (3) machine-check semantic models of subtyping for session types
%% \cite{DBLP:journals/mscs/BernardiH16}; (4) study the decidability
%% of~$\testleqS$.  We conjecture that in Selinger asynchronous setting the
%% \mustpreorder is undecidable.

%% More in general, given the practical relevance of asynchronous
%% communication, it seems crucial %
%% not only to adapt the large body of theory for synchronous
%% communication to the asynchronous setting but also to resort to
%% machine supported reasoning to do it. This paper is meant to be a step
%% forward in this direction.
