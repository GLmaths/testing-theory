\section{Bar-Induction}
\label{sec:bar-induction}

In this appendix we present our treatment of the \barinduction principle.
\rsec{visual-intro-bar-induction} is an informal introduction to the intuitions
behind \barinduction. A reader already acquainted with this principle may read
directly \rsec{bar-induction-technicalities}.



\subsection{A visual introduction}
\label{sec:visual-intro-bar-induction}

\begin{figure*}[t]
  \hrulefill
  \begin{center}
        \begin{tikzpicture}
        \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
        \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
        \node[state,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
        \node[state,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
        \node[state,below=+20pt of c] (g) {\myspace};
        \node[state,below=+20pt of g] (h) {\myspace};
        \node[state,below right=+20pt and +20pt of b] (e) {\scalebox{.6}{$\ok$}};
        \node[below=+20pt of e] (f) {\rotatebox{90}{$\ldots$}};

        \path[->]
        (a) edge node[above,scale=.9] {$\tau$} (b)
        (b) edge node[above,scale=.9] {$\tau$} (d);
        \path[->]
        (b) edge node[above,scale=.9] {$\tau$} (e)
        (e) edge node[left,scale=.9] {$\tau$} (f);

        \path[->]
        (a) edge node[above,scale=.9] {$\tau$} (c)
        (c) edge node[left,scale=.9] {$\tau$} (g)
        (g) edge node[left,scale=.9] {$\tau$} (h);
        \end{tikzpicture}
  \end{center}


  \caption{The state transition system of client-server system.}
  \hrulefill
  \label{fig:client-server-sts}
\end{figure*}


We explain the difference between {\em extensional} definitions of
predicates and {\em \intentional} ones, by discussing how the two
different approaches make us reason on computational trees.


\begin{figure*}[t]
  \hrulefill
  \begin{center}
    \begin{tabular}{c@{\hskip 30pt}c@{\hskip 30pt}c}
      \scalebox{.7}{%
        \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,below=+20pt of c] (g) {\myspace};
          \node[state,below=+20pt of g] (h) {\myspace};
          \node[state,below right=+20pt and +20pt of b] (e) {\scalebox{.6}{$\ok$}};
          \node[below=+20pt of e] (f) {\rotatebox{90}{$\ldots$}};

          \path[->]
          (a) edge[thick, dashed, red] node[above,scale=.9] {$\tau$} (b)
          (b) edge[thick, dashed, red] node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge node[above,scale=.9] {$\tau$} (e)
          (e) edge node[left,scale=.9] {$\tau$} (f);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c)
          (c) edge node[left,scale=.9] {$\tau$} (g)
          (g) edge node[left,scale=.9] {$\tau$} (h);
        \end{tikzpicture}
      }
      &
            \scalebox{.7}{%
        \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,below=+20pt of c] (g) {\myspace};
          \node[state,below=+20pt of g] (h) {\myspace};
          \node[state,below right=+20pt and +20pt of b] (e) {\scalebox{.6}{$\ok$}};
          \node[below=+20pt of e] (f) {\rotatebox{90}{$\ldots$}};

          \path[->]
          (a) edge[thick, dashed,red] node[above,scale=.9] {$\tau$} (b)
          (b) edge[thick, dashed] node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge[thick, dashed, red] node[above,scale=.9] {$\tau$} (e)
          (e) edge[thick, dashed] node[left,scale=.9] {$\tau$} (f);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c)
          (c) edge node[left,scale=.9] {$\tau$} (g)
          (g) edge node[left,scale=.9] {$\tau$} (h);
        \end{tikzpicture}
      }
            &
                  \scalebox{.7}{%
        \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,below=+20pt of c] (g) {\myspace};
          \node[state,below=+20pt of g] (h) {\myspace};
          \node[state,below right=+20pt and +20pt of b] (e) {\scalebox{.6}{$\ok$}};
          \node[below=+20pt of e] (f) {\rotatebox{90}{$\ldots$}};

          \path[->]
          (a) edge[thick, dashed] node[above,scale=.9] {$\tau$} (b)
          (b) edge[thick, dashed] node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge[thick, dashed] node[above,scale=.9] {$\tau$} (e)
          (e) edge[thick, dashed] node[left,scale=.9] {$\tau$} (f);

          \path[->]
          (a) edge[thick, dashed, red] node[above,scale=.9] {$\tau$} (c)
          (c) edge[thick, dashed] node[left,scale=.9] {$\tau$} (g)
          (g) edge[thick, dashed] node[left,scale=.9] {$\tau$} (h);
        \end{tikzpicture}
      }
      \\
      \small (1) &
      \small (2) &
      \small (3)
    \end{tabular}
  \end{center}
  \caption{Extensional approach: finding successful prefixes in every
    maximal path of the computational tree.}
  \label{fig:extensional-path-by-path}
  \hrulefill
\end{figure*}


Suppose that we have a client-server system $\csys{\server}{\client}$
and that we want to prove either$\Must{\server}{\client}$
or $\musti{\server}{\client}$. For both proofs,
what matters is the state transition system (STS) of
$\csys{\server}{\client}$, i.e. %the subgraph of the LTS that contains only the $\tau$'s (i.e.
the computation steps performed by the client-server system at issue.
In fact it is customary to treat this STS as a computational tree,
as done for instance in the proofs of \cite[Lemma 4.4.12]{DBLP:books/daglib/0066919} and
\cite[Theorem 2.3.3]{TCD-CS-2010-13}.
In the rest of this subsection we discuss the tree depicted in \rfig{client-server-sts}.
It contains three maximal computations, the middle one being infinite.
In the figures of this subsection, the states in which the client
is successful (i.e. in the predicate $\goodSym$) contain the symbol $\ok$.

%% Consider the predicate $\Must$ - which is defined extensionally - and
%% suppose we want to prove that $\Must{\server}{\client}$ for some
%% $\server$ and $\client$.


\paragraph{The extensional approach}
To prove $\Must{\server}{\client}$, the extensional definition of
$\opMust$ requires checking that every maximal path in the tree in
\rfig{client-server-sts} starts with a finite prefix that leads to a
successful state.
The proof that $\Must{\server}{\client}$ amounts to looking
for a suitable prefix maximal path by maximal path, via a loop whose
iterations are suggested in \rfig{extensional-path-by-path}.
%In  \rfig{extensional-path-by-path}
There at every iteration a different maximal path (highlighted by
dashed arrows) is checked, and each time a successful prefix is found
(indicated by a red arrow), the loop moves on to the next  maximal
path. Once a maximal path is explored, it remains dashed, to denote
that there a succesful prefix has been found.
The first iteration looks for a successful prefix in the left-most
maximal path, while the last iteration looks
for a successful prefix in the right-most path.
In the current example the loop terminates because the tree in
\rfig{client-server-sts} has conveniently a finite number of maximal
paths, but in general the mathematical reasoning has to deal with
an infinite amount of maximal path. An archetypal example is the tree in
\rfig{unbounded}: it has countably many maximal paths, each one
starting with a successful prefix.



\paragraph{The \intentional\ approach}
Consider now the predicate $\opMusti$ - which is defined \intentional ly -
and a proof that $\musti{\server}{\client}$.
The base case of $\opMusti$ ensures that all the nodes that contain a
successful client (i.e. that satisfies the predicate $Q_2$, defined on
line 553 of the submission) are in $\opMusti$. Pictorially, this is the
step from (1) to (2) in \rfig{intensional-layer-by-layer}, where the
nodes in $\opMusti$ are drawn using dashed borders, and the freshly
added ones are drawn in red.
Once the base case is established, the inductive rule of $\opMusti$
ensures that any node that inevitably goes to nodes that are in
$\opMusti$, is also in the predicate $\opMusti$. This leads to the step
from (2) to (3) and then from (3) to (4).
Note that the argument is concise, for in the tree the depth at which
successful states can be found is finite. In general though is may not
be the case. The tree in \rfig{unbounded} is again the archetypal
example: every maximal path there contains a finite prefix that leads
to a successful state, but there is no upper bound on
the length on those prefixes.


\begin{figure*}[t]
  \hrulefill
  \begin{center}
    \begin{tabular}{c@{\hskip 30pt}c}
      \scalebox{.7}{%
        \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,below=+20pt of c] (g) {\myspace};
          \node[state,below=+20pt of g] (h) {\myspace};
          \node[state,below right=+20pt and +20pt of b] (e) {\scalebox{.6}{$\ok$}};
          \node[below=+20pt of e] (f) {\rotatebox{90}{$\ldots$}};

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (b)
          (b) edge node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge node[above,scale=.9] {$\tau$} (e)
          (e) edge node[left,scale=.9] {$\tau$} (f);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c)
          (c) edge node[left,scale=.9] {$\tau$} (g)
          (g) edge node[left,scale=.9] {$\tau$} (h);
        \end{tikzpicture}
      }
      &
      \scalebox{.7}{%
        \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,dashed,red,thick,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,dashed,red,thick,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,dashed,red,thick,below right=+20pt and +20pt of b] (e)
               {\scalebox{.6}{$\ok$}};
               \node[below=+20pt of e] (f) {\phantom{\rotatebox{90}{$\ldots$}}};

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (b)
          (b) edge node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge node[above,scale=.9] {$\tau$} (e);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c);
        \end{tikzpicture}
      }
      \\
      \small (1) &
      \small (2)
      \\[2.5em]
      \scalebox{.7}{%
                \begin{tikzpicture}
          \node[state,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,dashed,red,thick,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,dashed,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,dashed,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
          \node[state,dashed,below right=+20pt and +20pt of b] (e)
               {\scalebox{.6}{$\ok$}};
               \node[below=+20pt of e] (f) {\phantom{\rotatebox{90}{$\ldots$}}};

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (b)
          (b) edge node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge node[above,scale=.9] {$\tau$} (e);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c);
                \end{tikzpicture}

      }
      &
      \scalebox{.7}{%
                \begin{tikzpicture}
          \node[state,dashed,red,thick,rectangle,inner sep=3pt] (a) {$\csys{\server}{\client}$};
          \node[state,dashed,below left=+20pt and +20pt of a] (b) {\myspace};
          \node[state,dashed,below right=+20pt and +20pt of a] (c) {\scalebox{.6}{$\ok$}};
          \node[state,dashed,below left=+20pt and +20pt of b] (d) {\scalebox{.6}{$\ok$}};
%          \node[state,below=+20pt of c] (g) {\myspace};
%          \node[state,below=+20pt of g] (h) {\myspace};
          \node[state,dashed,below right=+20pt and +20pt of b] (e)
               {\scalebox{.6}{$\ok$}};
               \node[below=+20pt of e] (f) {\phantom{\rotatebox{90}{$\ldots$}}};

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (b)
          (b) edge node[above,scale=.9] {$\tau$} (d);
          \path[->]
          (b) edge node[above,scale=.9] {$\tau$} (e);

          \path[->]
          (a) edge node[above,scale=.9] {$\tau$} (c);
                \end{tikzpicture}
      }
      \\
      \small (3) &
      \small (4)
    \end{tabular}
  \end{center}
  \caption{\Intentional\ approach: visiting the tree bottom-up, starting from the bar.}
  \label{fig:intensional-layer-by-layer}
  \hrulefill
\end{figure*}

\paragraph{Do \extensional and  \intentional predicates coincide ?}
Extensional and \intentional\ definitions make us reason on
computational trees in strikingly different fashions:
{\em extensionally} we reason maximal path by maximal path,
while {\em \intentional ly} we reason bottom-up, starting
from the nodes in a predicate that bars the tree.\footnote{Whence the
name {\em bar}-induction.}
It is natural to ask whether reasoning in these different manners
ultimately leads to the same outcomes.
In our setting this amounts to proving that the predicates
$\opMust$ and $\opMusti$ are logically equivalent, and similarly for
the convergence predicates $\conv$ and $\convi$.
The proof that $\musti{\server}{\client}$ implies $\Must{\server}{\client}$ is - obviously - by induction on the derivation
of $\musti{\server}{\client}$.
Proving that the extensional predicates imply the \intentional\ ones
is, on the other hand, delicate, because we may have to deal with unbounded structures.
The tree in \rfig{unbounded} is once more the archetypal example:
it has countably many maximal paths, and there is no upper bound on the
depth at which successful states (i.e. nodes in the {\em bar}) are found.

In classical logic one can prove that
$\Must{\server}{\client}$ implies $\musti
{\server}{\client}$ by contradiction.
%
As we wish to avoid this reasoning principle, the only tool we have
is the axiom of \Barinduction, which states exactly that under
suitable hypotheses, extensionally defined predicates imply their
\intentional ly defined counter-parts.


\begin{figure}[t]
\hrulefill
\begin{center}
\begin{tikzpicture}
  \node[state](t){$\csys{\server}{\client}$};

  \node[state][below=  of t](p20){\myspace};
  \node[state][below=  of p20](p21){\myspace};
  \node[state][below=  of p21](p22){\scalebox{.6}{$\ok$}};

  \node[state][left=of p20] (p10) {\myspace};
  \node[state][below=of p10] (p11) {\scalebox{.6}{$\ok$}};

  \node[state][left =of p10] (p00) {\scalebox{.6}{$\ok$}};

  \node[state][right=of p20](p30){\myspace};
  \node[state][below=of p30](p31){\myspace};
  \node[state][below=of p31](p32){\myspace};
  \node[state][below=of p32](p33){\scalebox{.6}{$\ok$}};

  \node[][right=of p30](p5){\vdots\ldots\vdots};

%Edges
\path (t) edge[to] node[action,swap,scale=.9] {$\tau$} (p00)
      (t) edge[to] node[action,scale=.9] {$\tau$} (p10)
      (t) edge[to] node[action,scale=.9] {$\tau$} (p20)
      (t) edge[to] node[action,swap,scale=.9] {$\tau$} (p30)
      (t) edge[to] node[action,scale=.9] {$\tau$} (p5);

\path (p30) edge[to] node[action,scale=.9] {$\tau$} (p31)
      (p31) edge[to] node[action,scale=.9] {$\tau$} (p32)
      (p32) edge[to] node[action,scale=.9] {$\tau$} (p33)
      (p20) edge[to] node[action,scale=.9] {$\tau$} (p21)
      (p21) edge[to] node[action,scale=.9] {$\tau$} (p22)
      (p10) edge[to] node[action,scale=.9] {$\tau$} (p11);
\end{tikzpicture}
\end{center}
  \caption{An infinite branching computational tree where the
    {\em bar}\ $\ok$ is at unbounded depth.}
  \label{fig:unbounded}
\hrulefill
\end{figure}



\subsection{Inductive definitions of predicates}
\label{sec:bar-induction-technicalities}
We present the inductive characterisations of $\conv$ and $\opMust$ in any state
transition system (STS) \sts{S}{\to} that is countably branching.
%
In practice, this condition is satisfied by most concrete LTS of programming
languages, which usually contain countably many terms; this is %certainly
the case for \ACCS and for the asynchronous $\pi$-calculus.

Following the terminology of \cite{DBLP:conf/lics/BredeH21} we introduce
extensional and \intentional\ predicates associated to any decidable
predicate~$Q: S \to \mathbb{B}$ over an STS~$\sts{S}{\to}$.

\begin{definition}%[\coqBar{extensional_pred}, \coqBar{intentional_pred}]
  \label{def:def-bar}
  The \emph{\extensional\ predicate} $\mathsf{ext}_Q(s)$ is defined, for~$s \in
  S$, as
  \[
    \forall \eta \text{ maximal execution of~$S$} \wehavethat
    \eta_0 = s \implies %\;\Longrightarrow\;
    \exists n \in \N,\;
    Q(\eta_n)
  \]
  %
  The \emph{\intentional\ predicate} $\mathsf{int}_Q$ is the inductive predicate
  (least fixpoint) defined by the following rules:
  $$
  \begin{array}{l@{\hskip 3pt}l@{\hskip 20pt}l@{\hskip 3pt}l}
    \rname{axiom}
&    \begin{prooftree}
      Q(s)
      \justifies
      \mathsf{int}_Q(s)
    \end{prooftree}
    &
    \rname{ind-rule}
    &
    \begin{prooftree}
      s \to
      \qquad
      \forall s' \wehavethat  s \to s' \implies \mathsf{int}_Q(s')
      \justifies
      \mathsf{int}_Q(s)
    \end{prooftree}
  \end{array}
  $$
  \hfill$\blacksquare$
\end{definition}
\noindent
For instance, by letting
\begin{equation*}
  Q_1(\state) \;\iff\; \state \Nst{\phantom{\tau}} \qquad\qquad
  Q_2(\state, \client) \;\iff\; \good{\client}
\end{equation*}
\noindent
we have by definition that
\begin{equation}
  \tag{ext-preds}
  \label{eq:def-extensional-predicates}
  \state \conv \;\iff\; \mathsf{ext}_{Q_1}( \state ) \qquad\qquad
  \Must{ \server }{\client } \;\iff\;
  \mathsf{ext}_{Q_2}(\state, \client )
\end{equation}
that is the standard definitions of $\conv$ and $\opMust$ are \extensional.
Our aim now is to prove that they coincide with their \intentional\
counterparts. Since we will use the \intentional\ predicates in the rest of
the paper a little syntactic sugar is in order, let
%(\coqLTS{terminate}, \coqMT{must2})
\begin{equation}
  \tag{int-preds}
  \label{eq:def-intentional-predicates}
  %\begin{align*}
  \state \convi \;\iff\; \mathsf{int}_{Q_1}( \state ) \qquad\qquad
  \musti{ \server }{\client } \;\iff\;
  \mathsf{int}_{Q_2}(\state, \client )
%\end{align*}
\end{equation}

The proofs of soundness, \ie that the inductively defined predicates imply the extensional ones,
are by rule induction:
%\footnote{They could be exercises for first year graduate students in CS. If this is not the case, we are sorry that your students are no better than ours.}
\begin{lemma}%[\coqBar{intentional_implies_extensional}]
  \label{lem:intensional-implies-extensional}
  %$\sts{S}{\to}$
  For $\state \in S$,
  \begin{enumerate}[(a)]
  \item $\state \convi $ implies $\state \conv$,
  \item for every $\client \wehavethat \musti{\state}{\client}$ implies $\Must{ \state }{\client}$.
  \end{enumerate}
\end{lemma}



The proofs of completeness are more delicate. To the best of our knowledge, the ones about \CCS \cite{TCD-CS-2010-13,phdbernardi}
proceed by induction on the greatest number of steps necessary to arrive at
termination or at a successful state. Since the STS of \sts{\CCS}{\st{\tau}} is
finite branching, \koenigslemma\ guarantees that such a bound exists. This
technique does not work on infinite-branching STSs, for example the one of \CCS
with infinite sums \cite{DBLP:journals/corr/BernardiH15}.
%Consider for instance the process $\state$ in \rfig{inf-image-conv}, it is
%convergent because every sequence of $\tau$ that it performs is finite, yet
%there is no upper bound to the length of these sequences.
If we reason in classical logic, we can prove completeness without \koenigslemma
and also over infinite-branching STSs via a proof {\em ad absurdum}: suppose $p \conv$. If
$\lnot (p \convi)$ no finite derivation tree exists to prove $p \convi$, and
then we construct an infinite sequence of $\tau$ moves starting with $p$, thus $\lnot (p \conv)$.
%The limit of this technique is that it exists only in classical logic. To do
%away also with this limit,
Since we strive to be constructive we replace reasoning {\em ad absurdum} with a
constructive axiom: (decidable) \emph{\barinduction}. In the rest of this section we discuss this axiom, and adapt it to our \svrclt setting. This requires a little terminology.

\newcommand{\utree}{T_{\N}}


\paragraph{\Barinduction}
The axiom we want to use is traditionally stated using natural numbers.
%
We use the standard notations $\N^\star$ for finite sequences of natural numbers,
$\N^\omega$ for infinite sequences, and~$\N^\infty = \N^\star \cup \N^\omega$ for
finite or infinite sequences.
%
Remark that, in constructive logics, given $u \in \N^\infty$, we cannot do a
case analysis on whether $u$~is finite or infinite.
%
The set $\N^\infty$ equipped with the prefix order can be seen as a \emph{tree},
denoted $\utree$, in the sense of set theory: a tree is an ordered set~$(A,
\leq)$ such that, for each~$a \in A$, the set~$\{ b \mid b < a \}$ is
well-ordered by~$<$. A \emph{path} in a tree A is a maximal element in~$A$.
%
In the tree~$\N^\infty$, each node has~$\omega$ children, and the paths are
exactly the infinite sequences~$\N^\omega$.

A predicate~$P \subseteq \N^\star$ over finite words is a {\em bar} if every
infinite sequence of natural numbers has a finite prefix in~$P$. Note that a bar
defines a subtree of $\utree$ \emph{extensionally}, because it defines each path
of the tree, as a path~$u \in \N^\omega$ is in the tree if and only if there exists a finite
prefix which is in the bar~$P$.

A predicate~$Q \subseteq \N^\star$ is {\em hereditary} if
\[
  \forall w \in \N^\star, \;\;
  \text{if}\;\;
  \forall n \in \N, w \cdot n \in Q
  \;\;\text{then}\;\;
  w \in Q.
\]
%
\Barinduction states that the extensional predicate associated to a bar implies its \emph{\intentional} counterpart:
a predicate~$P_{\mathit{int}} \subseteq \N^\star$ which contains~$Q$ and which is
hereditary.


\renewcommand{\bar}{Q}
\newcommand{\pint}{P_{\mathit{int}}}


\begin{myaxiom}[Decidable bar induction over $\N$] %\coqBar{actual_bar_induction}]
  Given two predicates~$\pint, \bar$ over~$\N^\star$, such that:
  \begin{enumerate}
    \item for all $\pi \in \N^\omega$, there exists~$n \in
      \N$ such that $(\pi_1, \dots, \pi_n) \in \bar$;
    \item for all $w \in \N^\ast$, it is decidable whether $\bar(w)$ or~$\neg \bar(w)$;
    \item for all $w \in \N^\ast$, $\bar(w) \Rightarrow \pint(w)$;
    \item $\pint$ is hereditary;
  \end{enumerate}
  then $\pint$ holds over the empty word: $\pint(\varepsilon)$.
\end{myaxiom}

\Barinduction is a generalisation of the fan theorem, i.e. the
constructive version
of \koenigslemma \cite[pag. 56]{dummett2000elements},
%and the fundamental use of \barinduction is to prove that trees whose
%paths are well-founded are well-founded \cite[Proposition 7]{DBLP:conf/aplas/NakataUB11}.
and states that any extensionally well-founded tree~$T$ can be turned into an
inductively-defined tree~$t$ that realises~$T$ \cite{DBLP:conf/lics/BredeH21,kleene1965foundations}.

Our mechanisation of \barinduction principle is formulated as a Proposition that
is proved using classical reasoning, since it is not provable directly in the
type theory of Coq.
%
This principle though has a computational content, bar recursion, which,
currently, cannot be used in mainstream proof assistants such as Coq.

\paragraph{Admissibility.}
To show that the principle is admissible, we prove that it follows
from the Classical Epsilon (CE) axiom of the Coq standard library.
In short, CE gives a choice function $\epsilon$ such that if $p$ is a proof of
$\exists x: A, P x$, then $\epsilon(p)$ is an element of $A$ such that $P
(\epsilon(p))$ holds. It implies Excluded Middle, and thus classical reasoning,
because $A \vee \neg A$ is equivalent to $\exists b: bool, (b=true \land A) \vee
(b=false \land \neg A)$.
Since CE is guaranteed by the Coq developers to be admissible, our statement of
\barinduction is also admissible.


  %% for it is used by
  %% \cite{DBLP:books/daglib/0067558} in the proof of Theorem 17.4.14, and
  %% introduced in Exercise 17.5.17 of the same book.


%% Intuitively, \barinduction let us charaterize inductively $\conv$ if we pick as bar
%% the predicate $P(\pi)  = \pi \text{is finite} \and \pi \text{contains a stable state}$,
%% and as $Q$ the predicate defined by induction via the rule \rname{cnv},
%% %s in \rfig{rule-cnv},
%% %% which states that the set of convergent processes is the least fixed point of
%% %% The intuition for why \barinduction can be used to charaterize $\conv$, is that $P$
%% %% would correpond to the fact that a finite reduction sequence has reached a
%% %% stable state, and $Q$ would correspond to the inductive definition of convergence,
%% %% %would correpond to the fact that a finite reduction sequence has reached a
%% %% %stable state, and $Q$ would correspond to the inductive definition of convergence,
%% %% which states that the set of convergent processes is the least
%% i.e. the least fixed point of the function
%% %

%% \renewcommand{\stateA}{q}
%% \[
%%   X \subseteq \States
%%     \quad\longmapsto\quad
%%   \setof{ \state }{ \forall \stateA, \; \state \to \stateA \implies \stateA \in X }
%% \]
%% %which is easy to define as an inductive type in Coq.

%% %% The version of \barinduction hinted at above is not directly suitable for our
%% %% purpose, as we need to reason about reduction sequences instead of sequences of
%% %% natural numbers. The solution is of course to encode processes with natural
%% %% numbers.


\paragraph{Encoding states}
The version of \barinduction we just outlined is not directly suitable for our
purposes, as we need to reason about sequences of reductions rather than sequences
of natural numbers. The solution is to encode STS states by natural %processes with natural
numbers.
%
%We then encouter a more serious issue:
This leads to the following issue: the nodes of the tree~$\utree$ have a fixed
arity, namely~$\N$, while processes have variably many reducts, including
zero if they are stable.
To deal with this glitch, it suffices to
%Our solution is to
assume that there exists the following family of surjections:
%
%\begin{align*}
\renewcommand{\stateB}{q}
\begin{equation}
\label{eq:surjection}
%  F^s : \States \to \N  \\
  F( \state ) : \N \to \setof{ \stateB }{ \state \to \stateB }
%\end{align*}
\end{equation}
%
where a surjection is defined as follows.
%% which always imply the usual
%% definition, and is equivalent to it assuming the Axiom of Choice:
%
\begin{definition}
  A map~$f: A \to B$ is a surjection if it has a section~$g: B \to A$, that is,
  $f \circ g = \mathrm{Id}_B$.
\end{definition}
\noindent
This definition implies the usual one which states the existence of an
antecedent~$x \in A$ for any~$y \in B$, and it is equivalent to it if we assume
the Axiom of Choice.

Using this map~$F$ as a decoding function, any sequence of natural
numbers corresponds to a path in the STS. Its subjectivity means that all paths
of the LTS can be represented as such a sequence. This correspondence allows us
to transport bar induction from sequences of natural numbers to executions of
processes.

Note that such a family of surjections $F$ exists for \ACCS\ processes, and
generally to most programming languages, because the set $\Acttau$ is countable,
and so are processes.
%
This leads to the following version of \barinduction where words and
sequences are replaced by finite and infinite executions.
%
\begin{proposition}[Decidable bar induction over an STS]%~\coqBar{bar_induction}]
 Let~$\sts{S}{\to}$ be an STS such that a  surjection as in~(\ref{eq:surjection})
 exists. Given two predicates~$\bar, \pint$ over finite executions, if
  \begin{enumerate}
    \item for all infinite execution~$\eta$, there exists~$n \in
      \N$ such that $(\eta_1, \dots, \eta_n) \in \bar$;
    \item for all finite execution $\zeta$,
    $\bar(\zeta)$ or~$\neg \bar(\zeta)$ is decidable;
          %one can decide whether $P(\zeta)$ or~$\neg P(\zeta)$;
    \item for all finite execution $\zeta$, $\bar(\zeta) \Rightarrow \pint(\zeta)$;
    \item $\pint$ is hereditary, as defined above except that $\zeta \cdot q$ is a
      partial operation defined when~$\zeta$ is empty or its last state is~$p$
      and $p \to q$;
  \end{enumerate}
then $\pint$ holds over the empty execution: that is $\pint(\varepsilon)$ holds.
\end{proposition}
%
The last gap towards a useful principle is the requirement
that every state in our STS has an outgoing transition.
This condition is necessary to ensure the existence of the
surjection in \req{surjection}.
%
To ensure this requirement given any countably-branching STS, we enrich it by
adding a \emph{sink} state, which (a) is only reachable from stable states of
the original STS, and (b) loops. This is a typical technique, see for instance
\cite[pag. 17]{DBLP:books/aw/Lamport2002}.
%
\newcommand{\sinkto}{\mathrel{\to^{\kern-0.3pt\text{\smaller[.5]{\tiny\ensuremath{\top}}}}}}
\begin{definition}
  Define~$\mathit{Sink}(S, \to) \coloneqq \sts{S \cup \set{\top}}{\sinkto}$, where~$\sinkto$ is
  defined inductively as follows:
  \[
    p \to q \;\;\Longrightarrow\;\; p \sinkto q
    \qquad
    p \Nst{} \;\;\Longrightarrow\;\; p \sinkto \top
    \qquad
    \top \sinkto \top
  \]
\end{definition}
%
A maximal execution of~$\mathit{Sink}(S, \to)$ is always infinite, and it
corresponds (in classical logic) to either an infinite execution of~$S$ or a
maximal execution of~$S$ followed by infinitely many~$\top$.
%
We finally prove the converse of Lemma~\ref{lem:intensional-implies-extensional}.

\begin{proposition}%[\coqBar{extensional_implies_inductive}]
  \label{prop:ext-impl-int}
  Given a countably branching STS~$\sts{S}{\to}$, and a decidable predicate~$Q$
  on~$S$, we have that, for all~$s \in S$, $\mathsf{ext}_Q(s) \implies
  \mathsf{int}_Q(s).$
\end{proposition}
\noindent
Now we easily obtain completeness of the \intentional\ predicates.
\begin{corollary}
\label{cor:inductive-char-must}\label{cor:inductive-char-conv}
  For every $\server \in \States$,
  \begin{enumerate}
  \item $\state \conv $ implies $\state \convi$,
  \item for every $\client \wehavethat \Must{\server}{\client}$ implies $\musti{\server}{\client}$.
  \end{enumerate}
\end{corollary}
\begin{proof}
  Direct consequence of \rprop{ext-impl-int}, and
  \req{def-extensional-predicates} and
  \req{def-intentional-predicates} above.%
  %% %It is routine to check
  %% the following equivalences, which hold by definition,
  %% \begin{enumerate}
  %%   \item $\state \conv \iff \mathsf{ext}_{Q_1}(\state)$;
  %%   \item $\state \convi \iff \mathsf{int}_{Q_1}(\state)$;
  %%   \item $\state \Must \client \iff \mathsf{ext}_{Q_2}(\state, \client)$;
  %%   \item $\state \musti \client \iff \mathsf{int}_{Q_2}(\state, \client)$;
  %% \end{enumerate}
  %% %% where:
  %% %% \begin{align*}
  %% %%   Q_1(\state) \;&\iff\; \state \Nst{\phantom{\tau}}\\
  %% %%   Q_2(\state, \client) \;&\iff\; \good{\client}
  %% %% \end{align*}
\end{proof}






As we have outlined why \rcor{inductive-char-must} is true,
from now on we use $\convi$ and $\opMusti$ instead of $\conv$ and $\opMust$.
We now  present the properties of these predicates that we use
in the rest of the paper.
%main contributions of this paper, i.e. \rthm{testleqS-equals-ff},
%\rthm{logical-soundness}, \rthm{logical-completeness}.

Convergence along traces is obviously preserved by the strong transitions $\st{}$.

\begin{lemma}%[\coqConv{acnv_one_step_tau},\coqConv{acnv_one_step_mu}]
  \label{lem:acnv-aux}
  In every LTS,
  $\forevery \state, \stateA \in \States$ and $ \trace \in \Actfin$
  the following facts are true,
  \begin{enumerate}
    \item
       if $\state \cnvalong \trace$
      and $\state \st{\tau} \stateA$ then $\stateA \cnvalong \trace$,\label{pt:acnv-one-step-tau}
    \item
      $\forevery \mu \in \Act \wehavethat \state \cnvalong
      \mu.\trace$ and $ \state \st{\mu} \stateA \imply \state \cnvalong \trace$.\label{pt:acnv-one-step-mu}
  \end{enumerate}
\end{lemma}


\begin{lemma}%[\coqDer{wt_set_spec}, \coqDer{wt_set}]
  \label{lem:cnvalong-implies-finite-branching}
  For every $\trace \in \Actfin$ and
  $\state \in \ACCS$, if $ \state \cnvalong \trace$ then
  ${\cardinality{\setof{ \stateB }{\state \wt{ \trace} \stateB} }} \in \N.$
\end{lemma}
The hypothesis of convergence in \rlem{cnvalong-implies-finite-branching} is necessary.
%arbitrary sequences of silent moves, i.e. given a $q$ the set $
%\setof{q}{ p \wt{} q }$ need not be finite. In presence of recursion
This is witnessed by the process $p =  \rec{(x \Par \mailbox{\co{a}})}$,
which realises an ever lasting addition of a message to the mailbox:
$$
p \st{\tau}
p \Par \mailbox{\co{a}} \st{\tau}  p \Par \mailbox{\co{a} \Par \co{a}}
\st{\tau}  p \Par \mailbox{\co{a} \Par \co{a} \Par \co{a}} \st{\tau}
\ldots
$$
In more general languages also image-finiteness may fail. An example
is given on page 267 of \cite{DBLP:conf/mfcs/HennessyP80}.



%\subsubsection{Properties of the $\opMusti$ relation}
%\label{sec:properties-musti}


The predicate $\opMusti$ is preserved by atoms freely changing their locations in systems.
This is coherent with the intuition that the mailbox is a global and
shared one. For instance the systems
$ \csys{ a.\Nil \Par \mailbox{ \co{d} } }{ d.\Unit }$  and  $ \csys{  a.\Nil }{ d.\Unit
  \Par \mailbox{\co{d}} }$, which in the mechanisation are respectively
\begin{minted}{coq}
  (pr_par (pr_input a pr_nil) (pr_out d), pr_input d pr_succes)
\end{minted}
and
\begin{minted}{coq}
  (pr_input a pr_nil, pr_par (pr_input a pr_succes) (pr_out d))
\end{minted}
have the same mailbox, namely $\mailbox{ \co{d} }$.



%%% SUBSUMED BY WHIC LEMMA ?
%The following lemma is analogous to \cite[Lemma 6.9]{DBLP:journals/iandc/BorealeN95}.
%% \begin{lemma}%[\coqMT{must_output_swap}]
%%   \label{lem:must-i-output-swap}
%%   \label{lem:musti-output-swap}
%%   $\Forevery p, r  \in \States$, and $\mu \in \Names \wehavethat p \Par \mailbox{\co{\mu}} \musti r$ if and only if $p \musti r \Par \mailbox{\co{\mu}}$.
%% \end{lemma}



The predicate $\opMusti$ enjoys three useful properties:
%whose proofs we defer to \rapp{proofs-props-musti}, namey that
it ensures convergence of servers interacting with clients
that are not in a good state; it is preserved by internal computation
of servers; and it is preserved also by interactions with unhappy clients.
The arguments to show these facts are by rule induction on the
hypothesis $\musti{ \server }{\client }$.
The last fact is a consequence of a crucial property of $\opMusti$,
namely \rlem{must-output-swap-l-fw}.

\begin{lemma}%[\coqMT{must_terminate_or_happy}]
  \label{lem:must-terminate}
  Let $\genlts_A \in \obaFW$ and $\genlts_B \in \obaFB$.
  For every $\server \in \StatesA$, $\client \in \StatesB$ we have that
  $\musti{ \server }{\client }$ implies that $\server \convi$ or $\good{\client}$.
\end{lemma}



\begin{lemma}%[\coqMT{must_lts_tau_srv}]
  \label{lem:must-lts-a-tau}
  \label{lem:musti-preserved-by-left-tau}
  Let $\genlts_A \in \obaFW$ and $\genlts_B \in \obaFB$.
  For every $\server, \server' \in \StatesA$, $\client \in \StatesB$ we have that
  $\musti{\server}{\client} $ and $\server \st{\tau} \server'$ imply
  $\musti{\serverB}{\client}$.
\end{lemma}



\begin{lemma}
  \label{lem:good-preserved-by-lts-output-iff}
  For every $\genlts_B \in \oba$, $\client \in \StatesB$
  %% \TODO{the client is not used in the statement.} %%
  and name $\aa \in \Names$ such that
  $\serverA \st{\co{\aa}} \serverA'$ then
  $\good{\serverA}$ iff $\good{\serverA'}$.
\end{lemma}
\begin{proof}
  This is a property of \lstinline{Good}, more specifically
  \lstinline{good_preserved_by_lts_output} and \lstinline{good_preserved_by_lts_output_converse}.
\end{proof}


\noindent%
\textbf{\rlem{must-output-swap-l-fw}}
%\begin{lemma}[ Output swap ]
%  \label{lem:must-output-swap-l-fw}
  Let $\genlts_A \in \obaFW$ and
  $\genlts_B \in \obaFB$.
  $\Forevery \serverA_1, \serverA_2 \in \StatesA$,
  every $\client_1, \client_2 \in \StatesB$ and name $\aa \in \Names$ such that
  $\serverA_1 \st{\co{\aa}} \serverA_2$ and
  $\client_1 \st{\co{\aa}} \client_2$,
  if $\musti{\serverA_1}{\client_2}$ then $\musti{\serverA_2}{\client_1}$.
%\end{lemma}
\begin{proof}
  We proceed by induction on $\musti{\serverA_1}{\client_2}$.
  In the base case  $\musti{\serverA_1}{\client_2}$ is derived using the rule \mnow
  and thus $\good{\client_2}$.
  \rlem{good-preserved-by-lts-output-iff} implies that $\good{\client_1}$,
  and so we prove $\musti{\serverA_2}{\client_1}$ using rule \mnow.
  We are done with the base case.

  
  In the inductive case, the hypothesis $\musti{\serverA_2}{\client_1}$ has been derived
  via an rule \mstep, and we therefore know the following facts:
  \begin{enumerate}
  \item
    \label{must-output-swap-l-fw-h-2-1}
    \label{pt:output-swap-inductive-case-fact-1}
    $\csys{\serverA_1}{\client_2} \st{\tau} \csys{\hat{\server}}{\hat{\client}} $, and
  \item
    \label{pt:output-swap-inductive-case-fact-2}
    $\Forevery \serverA', \client'$ such that
    $\csys{\serverA_1}{\client_2}\st{\tau}\csys{\serverA'}{\client'}$ we have that
    $\musti{\serverA'}{\client'}$.
  \end{enumerate}

  
  We prove $\musti{\server_2}{\client_1}$ by applying rule \mstep. In turn this requires us to show that \begin{enumerate}[(i)]
  \item
    \label{must-output-swap-l-fw-g-1}
    $\csys{\server_2}{\client_1} \st{\tau}$, and that
  \item
    \label{must-output-swap-l-fw-g-2}
    for each $\server'$ and $\client'$ such that
    $\csys{\server_2}{\client_1} \st{\tau} \csys{\serverA'}{\client'}$,
    we have $\musti{\server'}{\client'}$.
  \end{enumerate}


  We prove (\ref{must-output-swap-l-fw-g-1}). The argument starts with
  a case analysis on how the transition
  (\ref{pt:output-swap-inductive-case-fact-1}) has been derived.
  There are the following three cases:
    \begin{description}
  \item[\stauserver]
    \label{must-output-swap-l-fw-g-1-1}
    \label{pt:must-output-proof-of-i-stauserver}
    a $\tau$-transition performed by the server such that
    $\serverA_1 \st{\tau} \hat{\server}$ and that $\hat{\client} = \client_2$, or
  \item[\stauclient]
    \label{must-output-swap-l-fw-g-1-2}
    \label{pt:must-output-proof-of-i-stauclient}
    a $\tau$-transition performed by the client such that
    $\client_2 \st{\tau} \hat{\client}$ and that $\hat{\server} = \server_1$, or
  \item[\scom]
    \label{must-output-swap-l-fw-g-1-3}
    \label{pt:must-output-proof-of-i-scom}
    an interaction between the server $\server_1$ and the client
    $\client_2$ such that 
    $\serverA_1 \st{\mu} \hat{\server}$ and that $\client_2 \st{\co{\mu}} \hat{\client}$.
    \end{description}


   %%%%%%%%% CASE STAUSERVER 
    In case \stauserver\ %% THE REFERENCE TO DESCRIPTION SEEMS NOT TO
    %% WORK (\ref{pt:must-output-proof-of-i-stauserver})
    we use the \outputtau axiom together with
    the transitions $\server_1 \st{\co{\aa}} \server_2$ and
    $\server_1 \st{\tau} \hat{\serverA}$
    to obtain that either:
    \begin{itemize}
  \item
    there exists a $\server_3$ such that $\serverA_2 \st{\tau} \server_3$ and
    $\hat{\server} \st{\co{\aa}} \server_3$, or
  \item
    $\server_2 \st{\aa} \server_3$.
  \end{itemize}
    In the first case $\server_2 \st{\tau} \server_3$ let us construct the transition
  $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\server_3}{\client_1}$ as required.
    In the second case recall that by hypothesis $\client_1 \st{\co{\aa}}
  \client_2$, and thus the transition  $\server_2 \st{\aa}
  \hat{\server}$ and rule \scom\ let us construct the desired reduction
    $\csys{\server_2}{\client_1} \st{\tau} \csys{\hat{\server}}{\client_2}$.


  %%%%%%%%% CASE STAUCLIENT
  In case \stauclient\ %(\ref{must-output-swap-l-fw-g-1-2})
  we use the \outputcommutativity axiom together with
  the transitions $\client_1 \st{\co{\aa}} \client_2 \st{\tau} \hat{\client}$
  to obtain a $\client_3$ such that $\client_1 \st{\tau} \client_3 \st{\co{\aa}} \hat{\client}$
  and it follows that there exists the silent move $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA_2~}{~\client_3}$.

  %%%%%%%%% CASE SCOM
  In case \scom\ %(\ref{must-output-swap-l-fw-g-1-3})
  we have that $\serverA_1 \st{\mu} \hat{\server}$ and $\client_2 \st{\co{\mu}} \hat{\client}$.
  We distinguish whether $\mu = \co{\aa}$ or not.
  If $\mu = \co{\aa}$ then observe that
  $\client_1 \st{\co{\aa}} \client_2 \st{\aa} \hat{\client}$.
  Since by hypothesis $\client_1,\client_2
  \in \StatesB$ and $\genlts_B \in \obaFB$ we apply 
  \outputfeedback axiom to these transitions and obtain $\client_1 \st{\tau}
  \hat{\client}$. An application of \scom\ let us construct
  the desired transition $\csys{\server_2}{\client_1} \st{\tau}
  \csys{\serverA_2}{\hat{\client}}$.

  
  If $\mu \neq \co{\aa}$ we apply the \outputconfluence axiom to the transitions
  $\server_1 \st{\co{\aa}} \server_2$ and $\serverA_1 \st{\mu} \hat{\server}$
  to obtain a $\server_3$ such that
  $\serverA_2 \st{\mu} \server_3$ and $\hat{\server} \st{\co{\aa}} \server_3$.
  We then apply the \outputcommutativity axiom to obtain
  $\client_1 \st{\co{\mu}} \client_3 \st{\co{\aa}} \hat{\client}$ for
  some $\client_3$.
  Finally, we have the desired $\csys{\server_2}{\client_1} \st{\tau} \csys{\hat{\server}}{\client_3}$
  thanks to the existence of an interaction between $\server_2$ and $\client_1$
  that follows from
  $\server_2 \st{\mu} \server_3$ and $\client_1 \st{\co{\mu}} \client_2$.
  This concludes the proof of  (\ref{must-output-swap-l-fw-g-1}).



  We now tackle (\ref{must-output-swap-l-fw-g-2}). First of all,
  note that the inductive hypothesis states the following fact,
  \begin{center}
  For every
  $\serverA', \client', \serverA_0$ and $\client_0$,
  such that
  $\csys{\serverA_1}{\client_2}\st{\tau}\csys{\serverA'}{\client'}$,
  $\serverA'\st{\co{\aa}}\serverA_0$
  and
  $\client_0\st{\co{\aa}}\client'$
  then
  $\musti{\serverA_0}{\client_0}$.
  \end{center}
  
  Fix a transition
  $$
  \csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA'}{\client'},
  $$
  we must show $\musti{\serverA'}{\client'}$.
  We proceed by case analysis on the rule used to derive the
  transition at issue, and the cases are as follows,
  \begin{enumerate}[(a)]
  \item
    \label{must-output-swap-l-fw-g-2-1}
    a $\tau$-transition performed by the server such that
    $\serverA_2 \st{\tau} \serverA'$ and that $\client' = \client_1$, or
  \item
    \label{must-output-swap-l-fw-g-2-2}
    a $\tau$-transition performed by the client such that
    $\client_1 \st{\tau} \client'$ and that $\serverA' = \serverA_2$, or
  \item
    \label{must-output-swap-l-fw-g-2-3}
    an interaction between the server $\serverA_2$ and the client
    $\client_1$ such that
    $\serverA_2 \st{\mu} \serverA'$
    and that 
    $\client_1 \st{\co{\mu}} \client'$.
  \end{enumerate}

    In case (\ref{must-output-swap-l-fw-g-2-1})
  we have $\server_2 \st{\tau} \server'$
  and $\client' = \client_1$ and hence we must show $\musti{\server'}{\client_1}$.
  We apply the \outputcommutativity axiom to
  the transitions $\server_1 \st{\co{\aa}} \server_2 \st{\tau} \server'$
  to obtain a $\server_3$ such that
  $\server_1 \st{\tau} \server_3 \st{\co{\aa}} \server'$.
  We apply the inductive hypothesis with
  $\serverA' = \server_3, \client' = \client_2, \server_0 = \server'$
  and $\client_0 = \client_1$ and obtain
  $\musti{\serverA_2}{\client_1}$ as required.


    In case (\ref{must-output-swap-l-fw-g-2-2})
  we have $\client_1 \st{\tau} \client'$ 
  and $\server' = \server_2$, we therefore must show $\musti{\server_2}{\client'}$.
  We apply the \outputtau axiom to
  the transitions $\client_1 \st{\tau} \client'$ and $\client_1 \st{\co{\aa}} \client_2$
  to obtain that
  \begin{itemize}
  \item either
    there exists a $\hat{\client}$ such that $\client_2 \st{\tau} \hat{\client}$ and
    $\client' \st{\co{\aa}} \hat{\client}$,
  \item or 
    $\client_2 \st{\aa} \client'$.
  \end{itemize}
  In the first case we apply the inductive hypothesis with
  $\serverA' = \serverA_1, \client' = \hat{\client}, \serverA_0 = \serverA_2$
  and $\client_0 = \client'$ and obtain $\musti{\serverA_2}{\client'}$ as required.
  In the second case,
  %% we apply the \outputcommutativity axiom with                      %%
  %% the transitions $\client_1 \st{\co{\aa}} \client_2$ and $\client_2 \st{\aa} \client'$ %%
  %% to obtain a $\hat{\client}$ such that                                                 %%
  %% $\client_1 \st{\aa} \hat{\client} \st{\co{\aa}} \client'$.                            %%
  the transitions $\server_1 \st{\co{\aa}} \server_2$ and $\client_2
  \st{\aa} \client'$ and rule \scom\ let us prove
  $\csys{\server_1}{\client_2} \st{\tau} \csys{\server_2}{\client'}$.
  We apply \rpt{output-swap-inductive-case-fact-2} to
  obtain $\musti{\serverA_2}{\client'}$ as required.

    We now consider the case (\ref{must-output-swap-l-fw-g-2-3}) in which
  $\serverA_2 \st{\mu} \serverA'$ and $\client_1 \st{\co{\mu}} \client'$.
  We must show $\musti{\serverA'}{\client'}$ and to do so we distinguish
  whether $\mu = \aa$ or not.

  If $\mu = \aa$ then we apply the $\outputdeterminacy$ axiom to the transitions
  $\client_1 \st{\co{\aa}} \client_2$ and $\client_1 \st{\co{\mu}} \client'$ to obtain
  that $\client_2 = \client'$.
  Since by hypothesis $\server_1, \server_2 \in \StatesA$ and $\genlts_\StatesA \in
  \obaFW$ we apply the \fwdfeedback\ axiom to the transitions
  $\server_1 \st{\co{\aa}} \server_2 \st{\aa} \server'$ to prove that 
  either $\server_1 \st{\tau} \server'$ or $\server_1 = \serverA'$ must hold.
  If $\server_1 \st{\tau} \server'$ then we have that
  $\csys{\server_1}{\client_2} \st{\tau} \csys{\server'}{\client_2}$.
  The property in (\ref{pt:output-swap-inductive-case-fact-2}) ensures that
  $\musti{\server'}{\client_2}$ and from $\client_2 = \client'$ we have that
  the required $\musti{\server'}{\client'}$ holds too.
  If $\serverA_1 = \serverA'$ then $\musti{\serverA'}{\client_2}$
  is a direct consequence of the hypothesis $\musti{\serverA_1}{\client_2}$.

  If $\mu \neq \aa$ then we are allowed to apply the
  \outputconfluence axiom to the transitions
  $\client_1 \st{\co{\aa}} \client_2$ and $\client_1 \st{\co{\mu}} \client'$
  to obtain a $\hat{\client}$ such that
  $\client_2 \st{\co{\mu}} \hat{\client}$
  and $\client' \st{\co{\aa}} \hat{\client}$.
  An application of the \outputcommutativity axiom to the transitions
  $\server_1 \st{\co{\aa}} \server_2 \st{\mu} \server'$
  provides us with a $\hat{\server}$ such that
  $\server_1 \st{\mu} \hat{\server} \st{\co{\aa}} \server'$.
  We now apply the inductive hypothesis with
  $\serverA' = \hat{\serverA}, \client' = \hat{\client}, \serverA_0 = \serverA'$
  and $\client_0 = \client'$ and obtain $\musti{\serverA_2}{\client'}$
  as required. This concludes the proof of
  (\ref{must-output-swap-l-fw-g-2}),
  and therefore of the lemma.
\end{proof}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% ORIGINAL PROOF BY PAUL
%%%%%%%%%%%%%%%%%%%%%
%%\begin{proof}
%%   We proceed by induction on $\musti{\serverA_1}{\client_2}$.

%%   In the base case  $\musti{\serverA_1}{\client_2}$ is derived using the rule \mnow
%%   and thus $\good{\client_2}$.
%%   \rlem{good-preserved-by-lts-output-iff} implies $\good{\client_1}$
%%   which lets us apply rule \mnow to show $\musti{\serverA_2}{\client_1}$
%%   and we are done with the base case.

%%   In the inductive case, the hypothesis $\musti{\serverA_2}{\client_1}$ has been derived
%%   by the \mstep rule such that:
%%   \begin{enumerate}
%%   \item
%%     \label{must-output-swap-l-fw-h-2-1}
%%     $\csys{\serverA_1}{\client_2}\st{\tau}$, and
%%   \item
%%     \label{must-output-swap-l-fw-h-2-1}
%%     $\Forevery \serverA', \client'$ such that
%%     $\csys{\serverA_1}{\client_2}\st{\tau}\csys{\serverA'}{\client'}$ we have that
%%     $\musti{\serverA'}{\client'}$.
%%   \end{enumerate}
%%   The inductive hypothesis is the following.
%%   \begin{center}
%%   For every
%%   $\serverA', \client', \serverA_0$ and $\client_0$,
%%   such that
%%   \\
%%   $\csys{\serverA_1}{\client_2}\st{\tau}\csys{\serverA'}{\client'}$,
%%   $\serverA'\st{\co{\aa}}\serverA_0$
%%   and
%%   $\client_0\st{\co{\aa}}\client'$
%%   then
%%   $\musti{\serverA_0}{\client_0}$.
%%  \end{center}

%%   We apply rule \mstep and need to show the following.
%%   \begin{enumerate}[(i)]
%%   \item
%%     \label{must-output-swap-l-fw-g-1}
%%     $\csys{\serverA_2}{\client_1} \st{\tau}$, and
%%   \item
%%     \label{must-output-swap-l-fw-g-2}
%%     for each $\serverA'$ and $\client'$ such that
%%     $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA'}{\client'}$,
%%     we have $\musti{\serverA'}{\client'}$.
%%   \end{enumerate}

%%   We first show (\ref{must-output-swap-l-fw-g-1}).
%%   We proceed by case-analysis on the transition (\ref{must-output-swap-l-fw-h-2-1}).
%%   It can either be due to:
%%   \begin{description}
%% %    \begin{enumerate}[(a)]
%%   \item[\stauserver]
%%     \label{must-output-swap-l-fw-g-1-1}
%%     a $\tau$-transition performed by the server such that
%%     $\serverA_1 \st{\tau} \serverA'$ with $\client' = \client_2$, or
%%   \item[\stauclient]
%%     \label{must-output-swap-l-fw-g-1-2}
%%     a $\tau$-transition performed by the client such that
%%     $\client_2 \st{\tau} \client'$ with $\serverA' = \serverA_1$, or
%%   \item[\scom]
%%     \label{must-output-swap-l-fw-g-1-3}
%%     an interaction between the server $\serverA_1$ and the client
%%     $\client_2$ such that:
%%     $\serverA_1 \st{\mu} \serverA'$ and $\client_2 \st{\co{\mu}} \client'$.
%%   \end{description}

%%   In case (\ref{must-output-swap-l-fw-g-1-1})
%%   we use the \outputtau axiom together with
%%   the transitions $\serverA_1 \st{\co{\aa}} \serverA_2$ and $\serverA_1 \st{\tau} \serverA'$
%%   to obtain that either:
%%   \begin{itemize}
%%   \item
%%     there exists a $\hat{\serverA}$ such that $\serverA_2 \st{\tau} \hat{\serverA}$ and
%%     $\serverA' \st{\co{\aa}} \hat{\serverA}$, or
%%   \item
%%     $\serverA_2 \st{\aa} \serverA'$.
%%   \end{itemize}
%%   In the first case $\serverA_2 \st{\tau} \hat{\serverA}$ allows us to provide the transition
%%   $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\hat{\serverA}}{\client_1}$ as required.
%%   In the second case we have $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA'}{\client_2}$
%%   because of the existence of an interaction between $\serverA_2$ and $\client_1$ such that
%%   $\serverA_2 \st{\aa} \serverA'$ and $\client_1 \st{\co{\aa}} \client_2$.

%%   In case (\ref{must-output-swap-l-fw-g-1-2})
%%   we use the \outputcommutativity axiom together with
%%   the transitions $\client_1 \st{\co{\aa}} \client_2$ and $\client_2 \st{\tau} \client'$
%%   to obtain a $\hat{\client}$ such that $\client_1 \st{\tau} \hat{\client} \st{\co{\aa}} \client'$
%%   and it follows that $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA_2}{\hat{\client}}$.

  
%%   In case (\ref{must-output-swap-l-fw-g-1-3}) we have that
%%   $\serverA_1 \st{\mu} \serverA'$ and $\client_2 \st{\co{\mu}} \client'$.
%%   We distinguish whether $\mu = \co{\aa}$ or not.
%%   If $\mu = \co{\aa}$ then we apply the axiom of \outputfeedback together with
%%   the transitions $\client_1 \st{\co{\aa}} \client_2$ and
%%   $\client_2 \st{\aa} \client'$ to obtain $\client_1 \st{\tau} \client'$ and
%%   thus the transition $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA_2}{\client'}$.
%%   If $\mu \neq \aa$ we apply the axiom of \outputconfluence with the transitions
%%   $\server_1 \st{\co{\aa}} \server_2$ and $\serverA_1 \st{\mu} \serverA'$
%%   to obtain a $\hat{\serverA}$ such that
%%   $\serverA_2 \st{\mu} \hat{\serverA}$ and $\serverA' \st{\co{\aa}} \hat{\serverA}$.
%%   We then apply the \outputcommutativity axiom to obtain
%%   $\client_1 \st{\co{\mu}} \client_2 \st{\co{\aa}} \client'$.
%%   Finally, we have $\csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA'}{\client_2}$
%%   because of the existence of an interaction between $\serverA_2$ and $\client_1$
%%   that follows from
%%   $\serverA_2 \st{\mu} \hat{\serverA}$ and $\client_1 \st{\co{\mu}} \client_2$.
%%   We are done with (\ref{must-output-swap-l-fw-g-1}).
  
  %% We now tackle (\ref{must-output-swap-l-fw-g-2}).
  %% This time we proceed by case-analysis on the transition
  %% $$
  %% \csys{\serverA_2}{\client_1} \st{\tau} \csys{\serverA'}{\client'}
  %% $$
  %% and we must show $\musti{\serverA'}{\client'}$.

  %% The transition can either be due to:
  %% \begin{enumerate}[(a)]
  %% \item
  %%   \label{must-output-swap-l-fw-g-2-1}
  %%   a $\tau$-transition performed by the server such that
  %%   $\serverA_2 \st{\tau} \serverA'$ with $\client' = \client_1$, or
  %% \item
  %%   \label{must-output-swap-l-fw-g-2-2}
  %%   a $\tau$-transition performed by the client such that
  %%   $\client_1 \st{\tau} \client'$ with $\serverA' = \serverA_2$, or
  %% \item
  %%   \label{must-output-swap-l-fw-g-2-3}
  %%   an interaction between the server $\serverA_2$ and the client
  %%   $\client_1$ such that:
  %%   $\serverA_2 \st{\mu} \serverA'$
  %%   and
  %%   $\client_1 \st{\co{\mu}} \client'$.
  %% \end{enumerate}

  
  %% In case (\ref{must-output-swap-l-fw-g-2-1})
  %% we have $\serverA_2 \st{\tau} \serverA'$
  %% and $\client' = \client_1$. We must show $\musti{\serverA'}{\client_1}$.
  %% We use the \outputcommutativity axiom together with
  %% the transitions $\serverA_1 \st{\co{\aa}} \serverA_2$ and $\serverA_2 \st{\tau} \serverA'$
  %% to obtain a $\hat{\serverA}$ such that
  %% $\serverA_1 \st{\tau} \hat{\serverA} \st{\co{\aa}} \serverA'$.
  %% We apply the inductive hypothesis with
  %% $\serverA' = \hat{\serverA}, \client' = \client_2, \serverA_0 = \serverA'$
  %% and $\client_0 = \client_1$ and obtain $\musti{\serverA_2}{\client_1}$ as required.


  %% In case (\ref{must-output-swap-l-fw-g-2-2})
  %% we have $\client_1 \st{\tau} \client'$
  %% and $\serverA' = \serverA_2$. We must show $\musti{\serverA_2}{\client'}$.
  %% We use the \outputtau axiom together with
  %% the transitions $\client_1 \st{\tau} \client'$ and $\client_1 \st{\co{\aa}} \client_2$
  %% to obtain that either:
  %% \begin{itemize}
  %% \item
  %%   there exists a $\hat{\client}$ such that $\client_2 \st{\tau} \hat{\client}$ and
  %%   $\client' \st{\co{\aa}} \hat{\client}$, or
  %% \item
  %%   $\client_2 \st{\aa} \client'$.
  %% \end{itemize}
  %% In the first case we apply the inductive hypothesis with
  %% $\serverA' = \serverA_1, \client' = \hat{\client}, \serverA_0 = \serverA_2$
  %% and $\client_0 = \client'$ and obtain $\musti{\serverA_2}{\client'}$ as required.
  %% In the second case, %% we apply the \outputcommutativity axiom with                      %%
  %% %% the transitions $\client_1 \st{\co{\aa}} \client_2$ and $\client_2 \st{\aa} \client'$ %%
  %% %% to obtain a $\hat{\client}$ such that                                                 %%
  %% %% $\client_1 \st{\aa} \hat{\client} \st{\co{\aa}} \client'$.                            %%
  %% we have $\serverA_1 \st{\co{\aa}} \serverA_2$ and $\client_2 \st{\aa} \client'$ such that
  %% $\csys{\serverA_1}{\client_2} \st{\tau} \csys{\serverA_2}{\client'}$.
  %% We apply the hypothesis (\ref{must-output-swap-l-fw-h-2-1}) and
  %% obtain $\musti{\serverA_2}{\client'}$ as required.

%%   We now consider the case (\ref{must-output-swap-l-fw-g-2-3}) in which
%%   $\serverA_2 \st{\mu} \serverA'$ and $\client_1 \st{\co{\mu}} \client'$.
%%   We must show $\musti{\serverA'}{\client'}$ and to do so we distinguish
%%   whether $\mu = \aa$ or not.

%%   If $\mu = \aa$ then we apply the $\outputdeterminacy$ axiom together with the transitions
%%   $\client_1 \st{\co{\aa}} \client_2$ and $\client_1 \st{\co{\mu}} \client'$ to obtain
%%   that $\client_2 = \client'$.
%%   By applying the axiom for forwarders with the two transitions
%%   $\serverA_1 \st{\co{\aa}} \serverA_2$ and $\serverA_2 \st{\aa} \serverA'$ we know that
%%   either $\serverA_1 \st{\tau} \serverA'$ or $\serverA_1 = \serverA'$ must hold.
%%   If $\serverA_1 \st{\tau} \serverA_2$ then we have that
%%   $\csys{\serverA_1}{\client_2} \st{\tau} \csys{\serverA_2}{\client_2}$.
%%   An application of (\ref{must-output-swap-l-fw-h-2-1}) ensures that
%%   $\musti{\serverA'}{\client_2}$ and from $\client_2 = \client'$ we have that
%%   $\musti{\serverA'}{\client'}$ holds too, as required.
%%   If $\serverA_1 = \serverA'$ then $\musti{\serverA'}{\client_2}$
%%   is a direct consequence of the hypothesis $\musti{\serverA_1}{\client_2}$.

%%   If $\mu \neq \co{\aa}$ then we are allowed to apply the
%%   \outputconfluence axiom with the transitions
%%   $\client_1 \st{\co{\aa}} \client_2$ and $\client_1 \st{\co{\mu}} \client'$
%%   to obtain a $\hat{\client}$ such that
%%   $\client_2 \st{\co{\mu}} \hat{\client}$
%%   and $\client' \st{\co{\aa}} \hat{\client}$.
%%   An application of the \outputcommutativity axiom with the transitions
%%   $\serverA_1 \st{\co{\aa}} \serverA_2$ and $\serverA_2 \st{\mu} \serverA'$
%%   provides us with a $\hat{\serverA}$ such that
%%   $\serverA_1 \st{\mu} \hat{\serverA}$ and $ \hat{\serverA} \st{\co{\aa}} \serverA'$.
%%   We then apply the inductive hypothesis with
%%   $\serverA' = \hat{\serverA}, \client' = \hat{\client}, \serverA_0 = \serverA'$
%%   and $\client_0 = \client'$ and obtain $\musti{\serverA_2}{\client'}$ as required.
%% \end{proof}
%% }

\begin{lemma}%[\coqMT{zip_lts_must}]
  \label{lem:musti-presereved-by-actions-of-unsuccesful-tests}
  Let $\genlts_A \in \obaFW$ and $\genlts_B \in  \obaFB$.
  For every $\server, \server' \in \StatesA$, $\client, \client' \in \StatesB$
  and every action $\mu \in \Act$ such that
  $\server \st{ \mu } \server'$ and $\client \st{ \co{\mu}} \client'$
  we have that $\musti{\server}{\client}$ and $\lnot \good{\client}$ implies $\musti{\server'}{\client'}$.%
\end{lemma}
%%%% ORIGINAL LEMMA ABOUT LTS HT
%%%%
%% \begin{lemma}[\coqMT{zip_lts_a_must}]
%%   \label{lem:musti-presereved-by-actions-of-unsuccesful-tests}
%%   $\Forevery p, r,  \hat{p}, \hat{r} \in \States$ and every $\mu \in
%%   \Act \wehavethat \musti{ \server }{\client } $ and $\lnot
%%   (\good{\client})$ imply that
%%   if $\server \sta{ \mu } \hat{ \server }$ and $\client \st{ \co{\mu}}
%%   \hat{r}$ then $\musti{ \hat{\server} }{ \hat{\client} }$.%
%% \end{lemma}
\noindent
\begin{proof}
  %\rlem{musti-presereved-by-actions-of-unsuccesful-tests}
  %%  It is a consequence of \rlem{must-output-swap-l-fw}.
  By case analysis on the hypothesis that $\musti{\server}{\client}$.
\end{proof}
