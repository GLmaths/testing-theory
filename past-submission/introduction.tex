\section{Introduction}
\label{sec:intro}
Code refactoring is a routine task to develop or update software, and
it requires methods to ensure that a program~$\serverA$ can be safely
replaced by a program~$\serverB$.  One way to address this issue is
via refinement relations, \ie preorders.  For programming languages,
the most well-known one is Morris \emph{extensional} preorder
\cite[pag.~$50$]{morris}, defined by letting~$p \leq q$ if for all
contexts~$C$, whenever~$C[p]$ reduces to a normal form~$N$,
then~$C[q]$ also reduces to~$N$.



{\bfseries Comparing servers.}
This paper studies a version of Morris preorder for
\nondeterministic asynchronous \svrclt systems.
In this setting it is natural to reformulate the preorder by replacing
reduction to normal forms (\ie termination) with a suitable
\emph{liveness} property.
Let~$\csys{ \server }{ \client }$ denote a {\em \svrclt\ system},
that is a parallel composition in which the identities of the
server~$\server$ and the client~$\client$ are distinguished, and
whose computations have the form
$
\csys{\server~}{~\client} =
\csys{ \server_0 }{ \client_0 } \st{ }
\csys{ \server_1 }{ \client_1 } \st{ }
\csys{ \server_2 }{ \client_2 } \st{ } \ldots,
$
where each step represents either an internal computation
of one of the two components, or an interaction between them.
Interactions correspond to handshakes, where
two components ready to perform matching input/output actions
advance together.
We express liveness by saying that  $\server \text{ \emph{must pass} }
\client$, denoted $\Must{ \server }{ \client }$, if in every maximal
computation of $\csys{ \server }{ \client
}$ there exists a state $\csys{ \server_i}{ \client_i}$ such that
$\good{\client_i}$, where~$\goodSym$ is a decidable predicate
 indicating that the client has reached a successful state.
Servers are then compared according to their capacity to
satisfy clients, \ie via contexts of the form~$\csys{[-]}{\client}$
and the predicate~$\opMust$.
%namely to lead clients to successful states, \ie via
%In other words, servers are compared
%via contexts of the form~$\csys{[-]}{\client}$.
%, as argued also by \cite{DBLP:phd/us/Thati03}.
Morris preorder %, when restricted to computations leading to
%successful states,
then becomes the \mustpreorder\
by De Nicola and Hennessy~\cite{DBLP:journals/tcs/NicolaH84} :
%\begin{equation}
%  \label{eq:must-preorder}
%%
$
  \serverA \testleqS \serverB \text{ when } \forall \client \wehavethat
  \Must{\serverA}{\client} \implies
  \Must{\serverB}{\client}.
  $
%%\end{equation}


  {\bfseries Advantages.}
  The \mustpreorder is by definition liveness preserving,
  because $\Must{ \server }{ \client }$ literally means that
  ``in every execution something good must happen (on the client
  side)''.  Results on~$\testleqS$ thus shed light on
  liveness-preserving program transformations.

  The~\mustpreorder is independent of any particular calculus,
  as its definition requires simply
  (1) a reduction semantics for the parallel composition
  $\csys{ \server }{ \client }$, and (2)
  a predicate $\goodSym$ over programs.
  %%% LONG VERSION
  %% We thus do not fix any particular calculus:
  %% we assume a way of describing how servers and clients interact
  %% with the environment, and use it to define the semantics of $\csys{
  %%   - }{ - }$.
  %%As a result,
  Hence~$\testleqS$
  % the relation~$\testleqS$
  % lets us compare software components
  may relate servers written in different languages. For instance, servers written in
  \textsc{OCaml} may be compared to servers written in \textsc{Java}
  according to clients written in \textsc{Python}, because all these
  languages communicate using the same basic protocols.
  %%VERY DODGY STATEMENT:  that we are able to model.

  {\bfseries Drawback.}
  The definition of the \mustpreorder is {\em contextual}: proving that
  $\serverA~\testleqS~\serverB$ requires analysing an {\em
  infinite} amount of clients, and so the definition of
the preorder does not entail an effective proof method.
A solution to this problem is to define an {\em alternative (semantic)
  characterisation} of the preorder~$\testleqS$, \ie a
preorder~$\altleq$ that coincides with~$\testleqS$
and does away with the universal quantification over clients (\ie contexts).
In {\em synchronous} settings, i.e. when both input and output
actions are blocking, such alternative characterisations have been thoroughly
investigated, %for instance
typically via a behavioural approach.






\begin{figure}[t]
  \hrulefill
  \begin{center}
    \begin{minipage}{4cm}
        \centering
      \begin{tikzpicture}
        \node[state,scale=0.8] (s1) at (6,0) {$\server_0$};
        \node[state,scale=0.8,below of=s1,left of=s1] (s2) {$\server_1$};
        \node[state,scale=0.8,below of =s1,right  of=s1] (s3) {$\server_2$};
        \node[state,scale=0.8,below of=s2] (s4) {$\server_3$};
        \node[state,scale=0.8,below of=s3] (s5) {$\server_4$};

        \node[scale=0.8, below of = s5] (dummy) {$$};

        \path[->]
        (s1) edge node [above left,scale=0.8] {$\texttt{str}$} (s2)
        (s1) edge node [above right,scale=0.8] {$\texttt{float}$} (s3)
        (s2) edge node [left,scale=0.8] {$\co{\texttt{int}}$} (s4)
        (s3) edge node [right,scale=0.8] {$\co{\texttt{long}}$} (s5);
      \end{tikzpicture}
      \end{minipage}%
      \begin{minipage}{4cm}
        \centering\vskip-0.95em
      \begin{tikzpicture}
        \node[state,scale=0.8] (s0) at (0,0) {$\client_0$};
        \node[state,dashed,scale=0.8,below right = +15pt and +15pt of s0] (s1) {$\client_2$};
        \node[state,scale=0.8,below left = +15pt and +15pt of s0] (s2) {$\client_1$};
        \node[state,dashed,scale=0.8,below right = +15pt and +15pt of s2] (s3) {$\client_3$};

        \path[->]
        (s0) edge node [above left,scale=0.8] {$\co{\texttt{str}}$} (s2)
        (s0) edge node [above right,scale=0.8] {$\texttt{int}$} (s1)
        (s2) edge node [below left,scale=0.8] {$\texttt{int}$} (s3)
        (s1) edge node [below right,scale=0.8] {$\co{\texttt{str}}$} (s3);
    \end{tikzpicture}
  \end{minipage}
  \end{center}
  \vskip-1.5em
  \caption{The behaviours of a server $\server_0$ and of a client $\client_0$.}
  \label{fig:first-example}
  \hrulefill
\end{figure}



{\bfseries Behavioural characterisations.}
Alternative preorders %that capture~$\testleqS$
are usually
defined % as follows
in two steps:
%
- First, programs are associated with labelled transition systems (LTSs)
% such as the ones
like those in \rfig{first-example}, where transitions are
labelled by input actions such as $\texttt{str}$, %$\aa$,
output actions such as $\co{\texttt{str}}$, or the internal action
$\tau$ %(not featured in~Figure~\ref{fig:first-example}),
while dotted nodes represent successful states, \ie
those satisfying the predicate~$\goodSym$.
There, the server~$\server_0$ is ready to input either a string or a
float.
  %, and it is the environment that, by offering an output of
 % either type, will make~$\server$ move to either~$\server_1$
 % or~$\server_2$.
  The client~$\client_0$, on the other hand, is ready to either output
  a string, or input an integer. The input ${\tt int}$ makes the
  client move to the %$\goodSym$
  successful state~$\client_2$, while the output
  $\co{\tt{str}}$ makes the client move to the state $\client_1$, where it can
  still perform the input ${\tt int}$ to reach the %$\goodSym$
  successful state~$\client_3$. Output transitions enjoy a
  sort of %diamond property
  commutativity property on which we will return later.
  Programs $\serverA, \serverB, \client, \ldots$ are usually
  associated with their behaviours via inferences rules, which
  implicitly define a function $\ltsof{ - }$ that, given a
  program~$\server$, returns the LTS whose root is~$\server$.\\
  %%%%% END EXPLANATION EXAMPLE LTS IN FIG. 1
%
%  \noindent  
- Second, program behaviours, \ie~LTSs, are used to define the
alternative preorders for~$\testleqS$ %via
following one of two different
approaches: \MustSets or \AcceptanceSets.


{\bfseries Alternative preorders for synchrony.}  Both approaches were
originally proposed for % Milner's
% the Calculus of Communicating Systems ($\CCS$)
the calculus \CCS~\cite{DBLP:books/daglib/0098267},
where communication is synchronous.
The first alternative preorder, which we denote by~$\msleq$, was put
forth by De Nicola~\cite{DBLP:journals/tcs/NicolaH84}, and it
compares server behaviours according to their \MustSets, \ie~the sets of
actions that they may perform.
The second alternative preorder, which we denote by~$\asleq$, was put
forth by Hennessy~\cite{DBLP:books/daglib/0066919}, and it compares the
\AcceptanceSets of servers, \ie~how servers can be moved out of their
potentially deadlocked states.
Both these preorders characterise~$\testleqS$ in the
  following sense:
%In this case the characterisation is as follows,
%\ila{``In this case, the characterisation is:''}}
%Theorem 4.4.6 of \cite{DBLP:books/daglib/0066919} states the following
%characterisation: \ilacom{Do not mention the theorem, write simply
\begin{align}
      \label{eq:bhv-mustset-characterisation}
  \forall \serverA , \serverB \in \CCS \wehavethat & \serverA \testleqS \serverB
  \text{ iff } \ltsof{\serverA} \msleq \ltsof{\serverB}
  \\
    \label{eq:bhv-accset-characterisation}
  \forall \serverA , \serverB \in \CCS \wehavethat & \serverA \testleqS \serverB
  \text{ iff } \ltsof{\serverA} \asleq \ltsof{\serverB}
\end{align}

%% \gb{%
%% {\smaller[.99]
%% $$
%% \begin{array}{|l@{\hskip 1pt}l@{\hskip 2pt}c@{\hskip 2pt}l|l@{\hskip 1pt}l@{\hskip 2pt}c@{\hskip 2pt}l|}
%%   \hline
%%   \forall \serverA , \serverB \in \CCS \wehavethat & \serverA \testleqS \serverB
%%   & \text{ iff } & \ltsof{\serverA} \asleq \ltsof{\serverB}
%%   &
%%    \forall \serverA , \serverB \in \obaFB
%%     \wehavethat& 
%%     \serverA \testleqS \serverB
%%     &\text{ iff }&
%%     \liftFW{\serverA} \msleq \liftFW{\serverB}
%% \\
%%   \label{eq:bhv-mustset-characterisation}
%%   \forall \serverA , \serverB \in \CCS \wehavethat & \serverA \testleqS \serverB
%%   & \text{ iff } & \ltsof{\serverA} \msleq \ltsof{\serverB}
%%   &
%%   \forall \serverA , \serverB \in \obaFB
%%     \wehavethat&
%%     \serverA \testleqS \serverB
%%     &\text{ iff }&
%%     \liftFW{\serverA} \asleq \liftFW{\serverB}
%%     \\[2pt]
%%     \hline
%%     \multicolumn{4}{c}{\text{(a) Seminal results}}
%%     &
%%     \multicolumn{4}{c}{\text{(b) Novel results}}
%% \end{array}
%% $$
%% }
%% }%% \gb

%For instance \cite{DBLP:journals/iandc/BorealeNP02} use it
%in an asynchronous settings, \ilacom{I would not mention asynchronous
%  approaches here. I would only do it after we start talking about the
%  asynchronous case, namely after the paragraph ``On the Internet,
%  though\ldots''} and
%% REDUNDANT FOR WE ALREADY SAID IT ABOVE
%% In both~(\ref{eq:bhv-accset-characterisation}) and~(\ref{eq:bhv-mustset-characterisation}),
%% $\CCS$ is Milner's Calculus of Communicating Systems
%% \cite{DBLP:books/daglib/0098267}, and thus~$\serverA$ and~$\serverB$
%% are syntactic terms.
%%   There the server~$\server$ is \ila{initially} in a {\em stable state}: it
%% cannot perform any $\tau$ move, but \ila{it} is ready to input either a string
%% or a float, and it is the environment that, by offering an output of
%% either type, will make~$\server$ move to a different state.
%% Hence,~$\server_0$ models an {\em external} choice. The
%% client~$\client$, on the other hand, can either output a string, or
%% move to a different state via an internal computation.
%This is a form of {\em internal choice}. \ilacom{To my view, this does
%  not represent an internal choice - which should have both outcoming
%  transitions labelled by $\tau$ - but rather a parallel composition
%  of the output $\co{\texttt{str}}$ with the action $\tau$, as
%  witnessed by the fact that the LTS is diamond shaped (cf axiom
%  \ila{\outputtau).}}
%can interact
  %In either case, in each maximal computation of $\csys{ \server }{ \client }$ the client will eventually reach a successful state.}

%%%%%%%%% ILARIA: Logical characterisation, commented off 23/11/23

% {\em Logical} characterisations of~$\testleqS$, instead,
% require defining when a program~$\server$ models a certain
% formula~$\phi$, denoted $\server \models \phi$, where
% formulae belong typically to the recursive Hennessy-Milner
% logic, \ie the modal $\mu$-calculus, and the
% characterisations essentially identify the fragment~$L$
% of this logic, which is necessary and sufficient to capture
% the contextual preorder:
% \begin{equation}
%   \label{eq:logical-characterisation}
%   \forall \serverA , \serverB \in \CCS \wehavethat
%   \serverA \testleqS \serverB
%   \text{ iff }  (\forall \phi \in L \wehavethat \serverA \models \phi \implies \serverB \models \phi)
% \end{equation}
% These characterisations, given in Theorem 4.1 by
% \cite{DBLP:journals/jacm/AcetoH92} and indirectly by
% \cite{DBLP:journals/corr/abs-1011-6438},
% %are close in spirit to the
% %well-known theorem by \cite{DBLP:journals/jacm/HennessyM85},  and they
% identify the behavioural proprieties that are invariant under code refactoring done via~$\testleqS$.

%% OLD POPL TEXT
%% By contrast, {\em logical} characterisations
%% define~$\altleq$~comparing servers according to the formulae of the
%% recursive Hennessy-Milner logic\footnote{\ie the modal $\mu$-calculus}
%% that they satisfy: %
%% if $\serverA \altleq \serverB$ and~$\serverA$~satisfies a
%% formula~$\phi$,
%% %such %as~$\dmd{\texttt{str}}(\dmd{\texttt{int}}\true
%% % \wedge \dmd{\texttt{float}}\true)$
%% then~$\serverB$~also does.

%%%%%%%%% ILARIA: end of Logical characterisation %%%%%%%%%%%%%%%





{\bfseries Asynchrony.} %
In distributed systems, however,
communication is inherently asynchronous. For instance, the standard TCP
transmission on the Internet is asynchronous.
Actor languages like \textsc{Elixir} and \textsc{Erlang}
implement asynchrony via mailboxes, and both \textsc{Python} and
\textsc{JavaScript} offer developers the constructs
\textsc{async/wait}, to return promises (of results) or wait for
them.
In this paper we model asynchrony via \emph{output-buffered agents with
feedback}, as introduced by Selinger~\cite{DBLP:conf/concur/Selinger97}.
These are LTSs obeying the axioms in \rfig{axioms}, where~$\aa$ denotes
an input  action,~$\co{\aa}$ denotes an output  action,~$\tau$ denotes
the internal action, and~$\alpha$ ranges over all these actions.
For instance, the \outputcommutativity axiom states that an
output $\co{a}$ % $\co{a}$ that is followed by any action~$\alpha$,
can always be postponed: if $\co{a}$ is followed by any action~$\alpha$,
it can commute with it.
In other terms, outputs are
non-blocking,as illustrated by the LTS for~$\client_0$ in \rfig{first-example}.

\input{axioms-figure}

%The \outputfeedback axiom states that any message emitted by an agent
%is immediately available as input to the agent itself.

%% These axioms are typically enjoyed by LTS of calculi in which
%% communication takes place via a global unordered mailbox.
%% In turn, this communication model is the one that a priori allows for the most
%% \nondeterminismT, and this is why we favour it.


%% gb{The~$\tau$ action denotes internal computation of an agent, or a
%%   interactions between two agents. For instance, the computations
%%   in the system~$\csys{ \server_0 }{ \client_0 }$, where~$\server_0$
%%   and~$\client_0$ are give in \rfig{first-example} amount to
%%   $\csys{ \server_0 }{ \client_0 } \st{\tau}
%%   \csys{ \server_1 }{ \client_2 } \st{\tau} \csys{ \server_3 }{
%%   \client_3 }$.
%%   Note that \outputcommutativity implies a lack of causality between
%%   the client output $\co{{\tt str}}$ and its input ${\tt int}$, and hence
%%   the order of interactions depends on the order of the inputs in the
%%   server side.}
%%% NOT IMPORTANT ON A FIRST READ
%% We find it worth attention for it is the one that allows for the most
%% \nondeterminismT, and thus proofs that tackle this model can be adapted to more
%% deterministic settings, for instance when asynchrony is implemented
%% via ordered queues, as in \cite{josephs}.
%% The more deterministic the semantics, the easier the reasoning,
%% as already shown by theories of \mustpreorder in \CCS as compared
%% to the ones for session types \cite{DBLP:journals/mscs/BernardiH16}.
%% In output-buffered agents, outputs enjoy the \outputcommutativity\ and

%% \outputfeedback\ axioms.
{\bfseries Theoretical issues.} % due to asynchrony.}
The practical importance of asynchrony motivates a % suitable
specific study of~$\testleqS$. Efforts in this direction have
already been made, all of which focussed on process calculi
\cite{DBLP:conf/fsttcs/CastellaniH98,DBLP:journals/iandc/BorealeNP02,DBLP:phd/us/Thati03,DBLP:journals/jlp/Hennessy05}.
% The axioms in \rfig{axioms}, though, create an asymmetry between output
% and input actions, because they % force
% impose properties only over the outputs.
Note that the  axioms in \rfig{axioms} impose conditions
  only over outputs. This asymmetric treatment of inputs and outputs
substantially complicates the proofs of completeness and soundness of
the alternative characterisations of~$\testleqS$.
%% LONG VERSION
%% For instance, the phenomenon leaps out in the completeness proofs of alternative
%% characterisations, for their arguments depend on the contexts (\ie
%% clients), and the standard reasoning requires clients with blocking
%% outputs, that do not exist in the asynchronous setting.  As a
%% consequence, the results in (\ref{eq:bhv-mustset-characterisation})
%% and (\ref{eq:bhv-accset-characterisation}) do not hold in settings
%% where programs communicate by modifying a shared unordered buffer
%% \cite{DBLP:conf/concur/Selinger97,DBLP:conf/ecoop/HondaT91,
%%   boudol:inria-00076939}.
% and hence outputs are {\em non-blocking}.
%% For instance, \cite{DBLP:conf/fsttcs/CastellaniH98}
%% give simple counterexamples to~(\ref{eq:bhv-accset-characterisation})
%% in the setting of asynchronous \CCS (ACCS). There $ {\tt str}.\Nil
%% \testleqS \Nil $, \ie a server that does nothing is as good as a
%% server than can input a  string, while $ {\tt str}.\Nil \not \asleq
%% \Nil $.
%As for
To underline the subtleties due to asynchrony, we note that the completeness
result for asynchronous
  \CCS given by Castellani and Hennessy
  in~\cite{DBLP:conf/fsttcs/CastellaniH98},
  and subsequently extended to the $\pi$-calculus by 
  Hennessy~\cite{DBLP:journals/jlp/Hennessy05},
  is false (see \rapp{counterexample}).

% the technical work to obtain
% completeness (lemmas 3.26 and 3.27 there) to the reader.
%% LONG VERSION
%% Similarly
%% for Theorem 5.3 of \cite{DBLP:phd/us/Thati03}, which is presented as
%% a ``simple adaptation of the [\ldots] characterisation [\ldots] over
%% asynchronous CCS \cite{DBLP:conf/fsttcs/CastellaniH98}'', and
%% therefore not provided with a proof.  Instead,
%% \cite{DBLP:journals/iandc/BorealeNP02} change the definition of the
%% alternative preorder to arrive at a characterisation.


%% \footnote{It should be noted also that the behavioural preorder of
%% \cite{DBLP:conf/fsttcs/CastellaniH98} relies on acceptance sets,
%% while the one given in  \cite[Definition 5.8]{DBLP:phd/us/Thati03}
%% relies on $\Must$-sets, so anyhow the proof of Theorem 5.3 should not
%% follow from the one by Castelanni and Hennessy, but rather from the
%% one of \cite{DBLP:journals/iandc/BorealeNP02}.}.
%%%%%%%%% ILARIA: moved earlier 23/11/23 %%%%%%%%%%%%%%%%%%%
% On the Internet, though, communication is {\em asynchronous}, because so is
% the standard TCP transmission; actor languages like
% \textsc{Elixir} and \textsc{Erlang} implement asynchrony via mailboxes, and
% both \textsc{Python} and \textsc{Javascript} offer developers the \textsc{async/wait}
% constructs, to return promises (of results) or to wait for them.
% The reality is thus in stark contrast with the state in which the
% existing theory of~$\testleqS$ lays, and calls for a solid study of
% this preorder in an asynchronous setting, via tools fit to make us
% tame the lengthy (and at times tedious) proofs about semantics of
% programming languages.
% To provide such a foundation, we mechanise our work in the Coq proof
% assistant.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



{\bfseries Contributions and paper structure.} Our main contributions
may be summarised as follows
  (where for each of them, we detail where it is presented):
%\ilacom{I would first give the contributions and then shortly describe
%  the paper structure at the end.}
\begin{itemize}
\item 
The first behavioural
characterisations of the \mustpreorder (\rthm{testleqS-equals-accleq},
\rthm{testleqS-equals-mustsetleq}), that are {calculus independent}, in
that both our definitions and our proofs work directly on LTSs.
%\leo{not just proofs, the statements too!}
%% NOT USEFULL HERE. GET TO THE POINT, FAST.
%% The only hypothesis we use is that
%% the servers at hand satisfy the axioms for output buffered agents
%% proposed by \cite{DBLP:conf/concur/Selinger97}, plus additional
%% two to obtain completeness.
%% These axioms for asynchrony allow the largest amount of
%% \nondeterminism in LTS, so our results hold in arguably
%% the most complex scenario wrt. message-passing.
Contrary to all the previous works on the topic, we show that the {\em
  standard} alternative preorders characterise the~\mustpreorder also
in Selinger asynchronous setting.  To this end, it suffices to
enrich the server semantics with {\em forwarding}, i.e. ensure that
servers are ready to receive any input message, as long as they store
it back in a global shared buffer. This idea, although we use it here in a slightly
different form, was pioneered by Honda et al.~\cite{DBLP:conf/ecoop/HondaT91}.
In this paper we propose a construction that works on any LTS (\rlem{liftFW-works})
and we show the following counterparts of Equations
(\ref{eq:bhv-mustset-characterisation}) and
(\ref{eq:bhv-accset-characterisation}),
where $\obaFB$ denotes the LTSs of output-buffered agents with
  feedback, and~$\liftFWSym$ is the function that enhances them with forwarding:
\begin{align}
  \forall \serverA , \serverB \in \obaFB
    \wehavethat&
    \serverA \testleqS \serverB
    \text{ iff }
    \liftFW{\serverA} \msleq \liftFW{\serverB}
    \tag{a}
    \\
\forall \serverA , \serverB \in \obaFB
    \wehavethat&
    \serverA \testleqS \serverB
    \text{ iff }
    \liftFW{\serverA} \asleq \liftFW{\serverB}
    \tag{b}
\end{align}

%% \begin{equation}
%%   \begin{array}{ll}
%%     \forall \serverA , \serverB \in \obaFB
%%     \wehavethat& 
%%     \serverA \testleqS \serverB
%%     \text{ iff }
%%     \liftFW{\serverA} \msleq \liftFW{\serverB}
%% %
%%     \\
%%     %
%% \forall \serverA , \serverB \in \obaFB
%%     \wehavethat&
%%     \serverA \testleqS \serverB
%%     \text{ iff }
%%     \liftFW{\serverA} \asleq \liftFW{\serverB}
%%     \end{array}
%% \end{equation}
  
%% $$
%% \begin{array}{l}
%%       \forall \serverA , \serverB \in \obaFB
%%     \wehavethat
%%     \serverA \testleqS \serverB
%%     \text{ iff }
%%     \liftFW{\serverA} \msleq \liftFW{\serverB}
%%     \\
%% \forall \serverA , \serverB \in \obaFB
%%     \wehavethat
%%     \serverA \testleqS \serverB
%%     \text{ iff }
%%     \liftFW{\serverA} \asleq \liftFW{\serverB}
%%     \end{array}
%%     $$
%%  \end{equation}
  \noindent
  % where $\serverA , \serverB \in \obaFB$ means that the
  % programs at hand are in LTSs of output-buffered agents with
  % feedback, and~$\liftFWSym$ is the function that lifts the LTSs
  % at hand to LTSs of forwarders.
  Quite surprisingly, the alternative preorders~$\asleq$ and~$\msleq$
  need not be changed. We present these results in \rsec{bhv-preorder}.
  Selinger axioms are fundamental to prove completeness,
  which we discuss in \rapp{bhv-completeness}.

  \item %
  The first constructive account of the \mustpreorder.
  % It shows
  We show that if the~$\opMust$ and termination
  predicates are defined {\em \intentionally} (in the sense of
  Brede and Herbelin~\cite{DBLP:conf/lics/BredeH21}),
  then~$\testleqS$ can be characterised constructively.
  The original definitions of~$\opMust$ and termination given
  by De Nicola~\cite{DBLP:journals/tcs/NicolaH84}, though, are {\em \extensional}.
  Showing that \intentional\ and \extensional\ definitions are logically
  equivalent is a known problem, discussed for instance by
  Coquand~\cite{notecoquand} and Brede and Herbelin~\cite{DBLP:conf/lics/BredeH21}.
  We follow their approach and adapt the \barinduction principle
  to our setting to prove the desired equivalences.
  Our treatment shows that \koenigslemma, which is a mainstay in the literature
  on the \mustpreorder, is actually unnecessary: the \barinduction
  principle suffices for our purposes\footnote{In fact even its
  version for finite branching
  trees, i.e. the fan theorem, suffices in the current treatment.}.
  Since Rahli et al.~\cite{DBLP:journals/jacm/RahliBCC19} have shown \barinduction
  to be compatible  with constructive type theory, we argue %believe
  that our development is entirely constructive.
  Due to space constraints, we explain the principle of \barinduction
  and how to adapt it to our usage in \rapp{bar-induction}, while in
  this extended abstract we merely employ the principle.

  
\item
  The first mechanisation of the
  theory of \mustpreorder in a fully nondeterministic setting,
  which consists of around 8000 lines of Coq.
  In \rapp{coq} we gather the Coq versions of all the
  definitions and the results used in the main body of the paper.
  %%% GOOD FOR LONG VERSION
  %% which, however, is self-contained: it presents in English all the
  %% definitions and arguments supporting our results.
  %% We hope this will help readers not fluent in Coq to understand our
  %% contributions, while giving fluent Coq users enough comments to
  %% smoothly navigate through the code.
\end{itemize}

  % We discuss the impact of the above contributions in \rsec{conclusion},
  % where we also present related and future works.
  % In \rsec{preliminaries}, we recall the
  % \mustpreorder and the other standard notions that
  % we use to develop our contributions.
In~\rsec{conclusion}, we discuss the impact of the above
contributions, as well as related and future work.
In \rsec{preliminaries}, we recall the necessary background
  definitions and illustrate them with a few examples.
% \mustpreorder and the other standard notions that
%   we use to develop our contributions.


%%%%%%% ILARIA: logical characterisation again, commented off 23/11/23
  % \newcommand{\arhml}{\textsc{arHML}}
%   Afterwards, in \rsec{logical-characterisation}, we focus on asynchronous \CCS (\ACCS),
%   and show the first logical characterisation of the
%   \mustpreorder for this calculus.
%   We need to fix a calculus because we need to explicitly transform
%   clients into formulae, and vice-versa. Our formulae belong to a
%   modal logic~$\arhml$ such that
% %  \begin{equation}
%   %    \label{eq:result-logical-char}
%   $$
%     \forall \serverA, \serverB \in \ACCS
%     \wehavethat \serverA \testleqS \serverB
%     \text{ iff } (\forall \phi \in\arhml  \wehavethat \serverA \models
%     \phi \implies \serverB \models \phi)
%     $$
% %  \end{equation}
%   \noindent
%   The formulae in $\arhml$ are similar to the ones of the
%   \textsc{mustHML} of \cite{TCD-CS-2010-13}, but they predicate only
%   over output actions. This is because in an asynchronous setting
%   input actions cannot be tested. The proof of this result lays bare
%   this fact.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



  %% \ilacom{Using simply $OF$ to denote the set of Selinger output-buffered agents with
  %% feedback, I would rewrite the above more succintly as:
  %% $$

  %%   \forall \serverA , \serverB \in \textsc{lts}_{OF}
  %%   \wehavethat
  %%   \serverA \testleqS \serverB
  %%   \text{ iff }
  %%   \textsc{lts}_{FW}(\serverA) \asleq \textsc{lts}_{FW}(\serverB).
  %%   $$}




  %% \gb{
%% \begin{example}
%%   In general $\musti{X}{\client}$ does not imply $\mustset{X}{\client}$.
%%   Let $X = \set{\Nil, \co{\aa}}$ and $\client = \aa.\Unit$.
%%   We have that $\musti{X}{\client}$, because $X \st{\co{\aa}} $ and $X \st{\co{\aa}} Y$ implies that $Y = \set{ \Nil }$
%%   and
%%   $$
%%   \begin{prooftree}
%%         {\good{\Unit}}
%%         \justifies
%%         {\begin{prooftree}
%%             \musti{\Nil}{\Unit}
%%             \justifies
%%                 { \musti{ \set{\Nil, \co{\aa}} }{\aa.\Unit} }
%%           \end{prooftree}%
%%         }
%%   \end{prooftree}
%%   $$
%%   On the other hand the definition of $\opMustset$ requires showing that, %something stronger:
%%   $\forall \server \in X \wehavethat \csys{ \server }{ \client } \st{\tau}$, and this
%%   %  For instance, we have that $\csys{ \set{\Nil, \co{\aa}} }{\aa.\Unit} \st{\tau} $,
%%   %  but
%%   in the for set $X$ at issue this is false, because $\Nil \in X$ and $\Nil \stable$,
%%   which together with the stability of $\client$ implies that $ \csys{ \server }{ \client } \stable $.
%% \end{example}

%%%%  OLD TEXT
  %% It is not true that $\forall \server \in \set{\Nil, \co{\aa}} \wehavethat \csys{ \serverA }{ \aa.\Unit } \st{\tau}$,
  %% because
%% However, using $\opMusti$ together with the lifting of LTS operating on sets leads to a subtle,
%% but critical, issue. \gb{Why is this an issue?}
%% This issue concerns the requirement of a silent transition for $\csys{X}{\client}$,
%% stated in the inductive rule.
  %%Indeed, T
%%   The definition of $\opMusti$ would require that $\csys{X}{\client} \st{\tau}$, where the definition of
%% $\opMustset$ requires something stronger:
%% $\forall\ \serverA \in X \wehavethat \csys{ \serverA }{ \client } \st{\tau}$.
%% For instance, we have that $\csys{\set{\Nil, \co{\aa}}}{\aa.\Unit} \st{\tau} $,
%% but it is not true that
%% $\forall\ \serverA \in \set{\Nil, \co{\aa}} \wehavethat \csys{ \serverA }{ \aa.\Unit } \st{\tau}$.

%%}

%% \item \TODO{Paul: Is it not true that $\musti{\server}{\client}$ if and only if $\musti{\set{ \server }}{\client}$ ?} NOT DONE AT ALL.
%%     Where is the counter-example ? Give an argument in \rexa{musti-not-directly-liftable-LTS-of-sets}.
%% \pl{
%%   While the statement in the first TODO is false, this one is, I strongly believe, correct.
%%   Why the issue raised above does not affect the statement here?
%%   Because of the way we defined the lifting of the transition relation on sets,
%%   \ie by letting
%%   $$
%%   X_\alpha = \setof{ \stateA }{ \exists \state \in X \suchthat \state \st{\alpha} \stateA }
%%   $$
%%   and $X \st{ \alpha } X_\alpha$, whenever $X_{\alpha} \neq$.
%%   As a consequence, when we universally quantify over each $X'$ such that
%%   $X \st{\alpha} X'$, we reason on the power set of the complete set of the
%%   transitions performed by $X$ with the action $\alpha$.
%%   More precisely, for each singleton $\set{\serverA'}$ such that
%%   $\set{\serverA} \st{\alpha} \set{\serverA'}$
%%   we require that $\csys{\set{\serverA'}}{\client'} \st{\tau}$ holds,
%%   and thus $\csys{\serverA'}{\client'} \st{\tau}$.

%%   I am working on a coq proof.
%% }

%%     \item\TODO{If we use $\rec{\tau.x}$ as definition of $\Omega$, then we
%%       need to add a state to the LTS of \pierre.} \ilacom{We don't
%% need to change the structure of the LTS of Pierre in Fig. 7. We only need to add a
%% $\tau$ before $\Omega$ in the two left-most boxes.}
%% \item \TODO{Paul: What is worth being discussed about the inductive rule in \rfig{rules-mustset} ?}
%% I will write something about this tomorrow (22.01.2024).
%%\item \TODO{Paul: All the TODOs in \rsec{soundness-bhv}}.


  %% WE DO NOT NEED THE PREFIX NOTATION; REVERTED TO INFIX.
  %%\item \TODO{Check comment after \rdef{must-extensional}. Why using the infix notation for $\opMust$ ?}
