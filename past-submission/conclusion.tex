\section{Conclusion}
\label{sec:conclusion}
\label{sec:discussion}

In this paper we have shown that the standard characterisations of
  the \mustpreorder by De Nicola and
  Hennessy~\cite{DBLP:journals/tcs/NicolaH84,DBLP:books/daglib/0066919}
  are sound and complete also in an asynchronous setting, provided servers are
  enhanced with the forwarding ability.
  \rlem{liftFW-works} shows that this lifting is always possible.
  Our results %\ila{closes the problem left open by \cite{Tanti2015TowardsSR},}
  are supported by %and is also
  the first mechanisation of the \mustpreorder, and increase proof
  (i.e. code) factorisation and reusability since the alternative preorders
  do not need to be changed when shifting between synchronous and
  asynchronous semantics: it is enough to parametrise the proofs on
  the set of non-blocking actions.
    % This result closes the problem left open by
  %   \cite{Tanti2015TowardsSR}, \ila{is supported by} %and is also
  %   the first mechanisation of the
  %   \mustpreorder, and increases \ila{proof} (i.e. code)
  % factorisation and reuse: we do not need to change the definitions of
  % the alternative preorders to reason on synchronous systems, we need
  % only to parametrise the proofs on the set of non-blocking actions.
%
  %% \ilacom{This paragraph seems slightly redundant. Omit
  %%   the first sentence (which appears already in the last line of the abstract)?} 
  %% \rthm{testleqS-equals-accleq} and
  %% \rthm{testleqS-equals-mustsetleq} suggest a technique to port
  %% characterisations of testing preorders from synchronous to
  %% asynchronous semantics.
%
% \rthm{testleqS-equals-accleq} and \rthm{testleqS-equals-mustsetleq}
% suggest a technique to port characterisations of testing
% preorders from synchronous semantics to asynchronous ones,
% i.e. by  enhancing servers with the forwarding ability.
% \rlem{liftFW-works} shows that this lifting is always possible,
% \gb{and \cite{DBLP:conf/birthday/BaldanBGV15} is another case-study,
%   for it shows that this technique works also for the $\May$-preorder.
%
  \rcor{testleqS-equals-failleq} states that \mustpreorder and failure
  refinement essentially coincide. This might spur further interest in
  the mechanisations of the latter
  \cite{HOL-CSP-AFP,DBLP:journals/acta/BaxterRC22}, possibly leading
  to a joint development.%
 %% LICS TEXT
 %%While this approach was originally suggested by \cite{DBLP:conf/fsttcs/CastellaniH98},
 %%Selinger axioms play a crucial role in the proof of completeness.
 %% NEW TEXT


{\bfseries Proof method for \mustpreorder.}
\rthm{testleqS-equals-asleq} and \rthm{testleqS-equals-mustsetleq}
endow researchers in programming languages for message-passing
software with a proof method for~$\testleqS$, namely: to define an LTS
that enjoys the axioms of output-buffered agents with feedback for the
language at issue.
% define an LTS for the language at issue,
% that enjoys the axioms of output-buffered agents with feedback.
%
%% \begin{enumerate}[(1)]
%% \item defining an LTS for their language, and
%% \item proving that the LTS is an instance of the typeclass for
%%   output-buffered agents with feedback.
%% \end{enumerate}
A concrete example of this approach is \rcor{characterisation-for-aCCS}.


{\bfseries Live programs have barred trees.}  We argued that a proof
of $\Must{\server}{\client}$ is a proof of liveness (of the
client). This paper is thus de facto an exemple that proving
liveness amounts to prove that a computational tree has a bar (identified
by the predicate $\goodSym$), and hence \barinduction is a natural way
to reason constructively on liveness-preserving manipulations.
%% LONG VERSION
  %% as
  %% it gives an inductive principle for properties Ã  la
  %% \cite{DBLP:journals/tse/Lamport77}: "for each execution, eventually
  %% something good happens".
  While this fact seems to be by and large 
  unexploited by the PL community, we believe that it may %in fact
  be of interest to practitioners reasoning on liveness
  properties %wishing to prove liveness results
  in theorem provers in particular, and to the PL
  community at large.

    {\bfseries Mechanisation.} %
    As observed %also
    by Boreale and
    Gadducci~\cite{DBLP:journals/tcs/BorealeG06},
    the \mustpreorder lacks a tractable proof method.  We thus argue
    that our contributions, being fully mechanised in Coq, are crucial
    to pursue non-trivial results about testing preorders for
    real-world programming languages.  Our mechanisation %code
    lowers the barrier to entry for researchers versed into theorem
    provers and %wanting
    wishing to use testing preorders; %, as they can
%  now rely on an existing implementation;
    adds to the toolkit of Coq users an alternative to the well-known
    (and already mechanised) bisimulation equivalence
    \cite{DBLP:conf/lics/Pous16}; and provides a starting point
    for researchers willing to study testing preorders and analogous
    refinements within type theory.  Our code is open-source and
    available on-line. Practitioners working on testing preorders may
    benefit from it, as there are analogies between reasoning
    techniques for \textsc{May}, $\opMust$, \textsc{Compliance},
    \textsc{Should}, and \textsc{Fair} testing.
    For instance Baldan et al. show with pen and paper
    that a technique similar to forwarding works to
    characterise the $\May$-preorder~\cite{DBLP:conf/birthday/BaldanBGV15}.
%  
  
    {\bfseries Future work.}  Thanks to \rthm{testleqS-equals-asleq}
    and \rthm{testleqS-equals-mustsetleq} we can now set out to
    (1) develop a coinductive characterisation for~$\testleqS$
    adapting the one in
    \cite{DBLP:journals/jacm/AcetoH92,DBLP:journals/mscs/BernardiH16};
    (2) devise an axiomatisation of~$\testleqS$ for asynchronous
    calculi, as done in
    \cite{DBLP:journals/fac/HennessyI93,DBLP:journals/iandc/BorealeN95,DBLP:books/daglib/0066919,DBLP:journals/tcs/Hennessy02}
    for synchronous ones; (3) study for which asynchronous
    calculi~$\testleqS$ is a pre-congruence; (4) machine-check
    semantic models of subtyping for session types \cite{DBLP:journals/mscs/BernardiH16}; (5) study the
    decidability of~$\testleqS$.  We conjecture that in Selinger
    asynchronous setting the \mustpreorder is
    undecidable.%\footnote{This conjecture is %shaped
%      reinforced by a private
%      communication with Sylvain Schmitz.}



{\bfseries Related work.}
\rapp{detailed-related-works} contains a detailed discussion of related works.
Here we highlight that the notion of forwarder was outlined in the
original paper on testing-preorders for asynchrony
\cite{DBLP:conf/fsttcs/CastellaniH98}, and then
used in the saturated LTS of \cite{DBLP:conf/birthday/BaldanBGV15}
to reason on the $\opMay$-preorder, and in \cite{DBLP:phd/us/Thati03}
to reason on a version of the \mustpreorder parametrised on the set of
tests.
Forwarders, also called ``links'', have applications outside of
testing theory, as shown by \cite{DBLP:journals/mscs/MerroS04}
and the recent \cite{DBLP:journals/tcs/DurierHS22}.
Characterising~$\testleqS$ directly on LTSs instead of calculi 
was suggested already in \cite{DBLP:books/daglib/0066919,phdbernardi}.
  %% Page numbers, FOR LONG VERSION
% on \cite[pag. 211]{DBLP:books/daglib/0066919} and \cite[pag. 93]{phdbernardi}
Selinger axioms, discussed also by \cite{DBLP:journals/mscs/BaldanBGM15}, are
crucial in our completeness proof.
Brouwer \barinduction principle is paramount to prove soundness
constructively.

%% we prove this for the LTS of \ACCS modulo $\equiv$ in
%% \rlem{ACCSmodulos-equiv-is-out-buffered-with-feedback}
%% and hence we obtain as a corollary of~\rthm{testleqS-equals-accleq}
%% a characterisation of~$\testleqS$ for this language:
%% $$
%% \forall \serverA, \serverB \in \modulo{\ACCS}{\equiv} \wehavethat \serverA \testleqS \serverB \text{ iff } \ltsFWof{\serverA} \asleq \ltsFWof{\serverB}.
%% $$

%%% LONG DISCUSSION FIT FOR A JOURNAL
%% Furthermore, our characterisations use the standard definitions of the
%% alternative preorders~$\msleq$ and~$\asleq$, which are simpler than
%% the ones proposed in \cite{DBLP:conf/fsttcs/CastellaniH98,
%%   DBLP:journals/iandc/BorealeNP02}.
%% Our approach places the complexity of reasoning on asynchrony into the LTSs themselves,
%% and, above all, into our proofs, which are more general than the
%% proofs of equations~(\ref{eq:bhv-mustset-characterisation})
%% and~(\ref{eq:bhv-accset-characterisation}) on
%% page~\pageref{eq:bhv-mustset-characterisation}.  This is the case
%% because proofs for the synchronous semantics are simpler than the ones
%% for the asynchronous one, since they do not have to tackle the
%% asymmetry between non-blocking outputs and blocking inputs.

%%In addition to the theoretical contributions, we provide a


  
%% Since the logic implemented by Coq is constructive, and since our proofs do
%% not use axioms other than \barinduction, they are constructive by construction.

%% In particular, the standard technique to prove soundness of
%% alternative characterisations


%


  %% and contradiction in the constructive sense: the negation of~$A$ is defined as
  %% ``$A$ implies~$\bot$'', so that, to prove the negation of~$A$, we can
  %% assume~$A$ holds and derive a contradiction.


